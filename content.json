{"posts":[{"title":"Echarts动态获取数据颜色丢失的问题","text":"解决图表颜色丢失的问题 问题描述：使用Echarts饼图从后台请求数据时，请求成功后图表颜色丢失，变成纯黑色了。 问题原因：12345678visualMap: { show: false, min: 0,// 数据最小值的颜色明暗度 max: 600,// 数据最大值的颜色明暗度 inRange: { colorLightness: [0,1] // 表示颜色的明暗程度 } }, 出现纯黑的情况是因为数据太小了，而max中设置的又太高，导致了只能以最暗的情况展示所有数据。 解决思路：一 、将max调小点。二、将数据做处理计算出各组数据的值在总量的比重后作为数组放在data内部，min和max设为0,1。这样就能根据比重显示明暗度了。 当然，也可以在后端返回数据的时候将value直接返回为比重也行。或者说多返回一个总量，前端自行处理也阔以。","link":"/2022/10/31/Echarts%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E9%A2%9C%E8%89%B2%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"Echarts常见问题整理","text":"前言本次项目中负责了一个使用Echarts做的页面，涉及的图表类型有 柱状图(横竖两种)、折线图、气泡图、漏斗图、饼图期间也遇到了不少问题，但是大部分的问题都是可以通过Echarts官方文档上找到解决办法的。下面记录一下问题及解决办法和Echarts的一些学习、码字心得。 一、常见问题记录1.如何创建一个自适应的Echarts图表（动态给Echarts图表当前高度初始化+窗口缩放Echarts图表自适应）讲道理这个问题一开始着实困扰我了大半天，因为页面需要自适应，根本不知道图表一开始具体的 Height 是多少。而且此次布局使用的是Flex布局，分左中右三块，每块上下各有一个图表，加一起是六个。这里有两种解决思路，各有优缺点吧，这次用的第二个。 提供的思路并非最优解，只是在解决本次项目的过程中效果比较好，如果有什么更好的想法欢迎指出 动态高度初始化思路一：通过css样式aspect-ratio（宽高比）解决因为采用的是Flex布局，而且是左中右三块，左右25%，中间50%，因此宽度是一定有的 此时，给图表的容器加上一个宽高比aspect-ratio，高度设置为100%，图表在初始化的时候就能根据宽高比初始化出来。 优点： 操作简单，css直接加就ok 对于宽高比确定的图表完美契合 图表不会变形 缺点 分配的宽度过大的话会影响整体布局（超出盒子范围） 不适合难以确定宽高比 或 图表不要求定型 的情况没办法使用 思路二：通过在父组件dom操作获取当前高度clientHeight（只读），作为参数调用子组件方法，在子组件获取到当前高度后初始化。优点 布局不会乱 适合难以确定宽高比 或 图表不要求定型 的情况 缺点 这样写的高度是定死的，除非再次传参初始化，否则在不同大小的显示器上就只有刷新后才能正常自适应。 代码实现父组件：关键代码 12345&lt;Histogram ref=&quot;echarts1&quot; /&gt;// 有五个类似的组件for (var i = 1; i &lt;= 5; i++) { this.$refs['echarts'+i].setHeight(document.getElementsByClassName('side-echarts-container')[0].clientHeight)} 子组件：关键代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;template&gt; &lt;div&gt; &lt;div id=&quot;hstogram&quot; class=&quot;charts&quot; :style=&quot;{'height':sideEchartsContainerHeight+'px','width':' 100%'}&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as echarts from 'echarts'import { getBarGraphData } from '../../api/dataStatistics.js'var option = { // color: ['rgb(245,33,45)', 'rgb(255,229,143)', 'rgb(11,115,255)'], color: [new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, color: '#f00' }, { offset: 0, color: '#f99' }]), new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, color: 'rgb(249, 173, 21)' }, { offset: 0, color: 'rgb(255,255,153)' }]), new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, color: 'rgb(11,115,255)' }, { offset: 0, color: 'rgba(0,255,255)' }]) ], legend: { textStyle: { color: 'white' }, top: 25 }, grid: { show: true, borderColor: 'rgba(255, 255, 255,0.5)' }, tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } }, xAxis: { type: 'category', axisLabel: { interval: 0, // 显示全部x坐标 // rotate: 35, color: 'rgba(255, 255, 255,1)' }, nameTextStyle: { align: 'center' }, splitLine: { show: true, lineStyle: { color: 'rgba(255, 255, 255,0.5)', width: 1, type: 'dashed' } } }, yAxis: { axisLabel: { color: 'rgba(255, 255, 255,1)' }, splitLine: { lineStyle: { color: 'rgba(255, 255, 255,0.5)', width: 1, type: 'dashed' } } }, series: [ { type: 'bar', barWidth: 10, itemStyle: { //柱形图圆角，鼠标移上去效果，如果只是一个数字则说明四个参数全部设置为那么多 normal: { //柱形图圆角，初始化效果 barBorderRadius:[15, 15, 0, 0] } } }, { type: 'bar', barWidth: 10, itemStyle: { //柱形图圆角，鼠标移上去效果，如果只是一个数字则说明四个参数全部设置为那么多 normal: { //柱形图圆角，初始化效果 barBorderRadius:[15, 15, 0, 0] } } }, { type: 'bar', barWidth: 10, itemStyle: { //柱形图圆角，鼠标移上去效果，如果只是一个数字则说明四个参数全部设置为那么多 normal: { //柱形图圆角，初始化效果 barBorderRadius:[15, 15, 0, 0] } } }, ]}export default { name: 'Histogram', data() { return { charsData: [], // 之后通过请求放数据，需要效果的可以先加进去看看 sideEchartsContainerHeight: 0 } }, methods: { setHeight(height){ this.sideEchartsContainerHeight = height this.getData() // 请求默认数据(无参数) this.$nextTick(function() { this.echartsInit() // 初始化echarts }) }, echartsInit() { myEcharts = echarts.init(document.getElementById('hstogram')) // 获取图表节点 myEcharts.setOption(option) } }}&lt;/script&gt; 窗口缩放时图表内容自适应其实图表本身是通过canvas这个容器画出来的，canvas在画完后想要让内容自适应只有重绘了。好在Echarts官方提供了这个函数resize() 123456789// 监听实现window.addEventListener('resize', function() { // bubbleChart 是图表的实例 echartsInstance（调用过init函数后） bubbleChart.resize()})// 手动调用chartsResize(){ bubbleChart.resize()} 通过全局设置监听，实现在窗口缩放时图表的重绘，当然这个监听对象加给谁都行，但是要记得销毁。 本次项目中将每个图表都搞成了一个组件（维护起来比较方便），然后在组件里面写的监听。其实感觉正确的写法应该是在父组件加监听，调6个子组件的resize()方法的，但是项目比较急，就没维护这块。 2.调整Echarts图表大小、位置、显示网格线通过在option中设置grid的四个值即可： 123456789option = { grid: { show:true, // 显示网格线 top:10, left:10， // bottom:10, // right:10 }} grid设置两个值即可确定图表的大小和位置。值可以是像 20 这样的具体像素值，可以是像 '20%' 这样相对于容器高宽的百分比，也可以是 'left', 'center', 'right'。如果 left 的值为'left', 'center', 'right'，组件会根据相应的位置自动对齐。 值得一提的是，grid中containLabel如果为true的话，grid决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置,常用于防止标签溢出的场景。为false，则只算由图标形成的区域。 网格的背景只有在设置show:true时才会起作用，默认为透明 3.柱状图根据x坐标数量动态判断柱状图柱条的宽度、防止x坐标过多导致重叠本次在写项目时，由于存在检索范围这一条件，导致x坐标的个数有时候很密集，有时候有很稀疏，所以就有了要根据x坐标的个数来动态改变柱状图柱子的宽度，来保证图表不会引起误解（1月份的柱子太宽占到了2月份的坐标）。 宽度问题图表的样式修改一般在series内的itemStyle里面，我们可以通过barwidth来修改柱状图柱条的宽度。 动态改变宽度的前提条件是我们需要知道数据量，也就是请求成功后的返回值。 12345678910111213141516// getBarGraphData 发出请求，.then表示请求成功后的回调函数，res为请求的返回值getBarGraphData().then(res =&gt; { let baseLength = 10 let resLength = 40 / res.data.length // 此处应该是 (图表宽度 / {请求返回的数据条数 * 每个x坐标展示的柱条个数})。结果可以稍微小点，便于更好的去展示。这里只是演示用，先写死了。 myEcharts.setOption({ series: [ { type: 'bar', barWidth: Math.min(baseLength, resLength) }, { type: 'bar', barWidth: Math.min(baseLength, resLength) }, { type: 'bar', barWidth: Math.min(baseLength, resLength) } ], dataset: { dimensions: ['product', '红', '黄', '蓝'], source: that.charsData } }) }) 初始化时可以不给数据，只写配置。在请求成功后通过setOption更新配置即可。 防止x坐标过多导致重叠两种解决办法 通过旋转一定的x坐标角度实现不重叠 123456789option = { xAxis: { axisLabel: { //interval: 0, // 显示全部x坐标 rotate: 35, color: 'rgba(255, 255, 255,1)' }, }} 显示部分x坐标，隔几个个x坐标显示一个（间隔的x坐标数目固定） 123456789option = { xAxis: { axisLabel: { interval: 1, // 是否显示全部x坐标 // rotate: 35, color: 'rgba(255, 255, 255,1)' }, }} 4.Echarts实现渐变色及更新数据后渐变消失的问题如果我们不给图表设置颜色，图表会默认从['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc']中挑选颜色。但是单纯设置颜色有时候丑的一批，所以加上渐变效果会好很多 线性渐变不知道为什么官方文档上没搜到，Echarts内部是带有一个渐变色生成器的 更多关于echarts.graphic的细节请参阅 就是不知道为啥，官方文档上没给出来这个东西。但其实是可以直接使用的，比如我希望柱状图的填充为渐变填充，我就可以这么写 1234567891011121314151617181920212223option = { color: [ // 第一个柱状图的颜色填充，参数依次对应 右/下/左/上 四个位置，1表示渐变色从正上方开始 // 第5个参数则是一个数组 用于配置颜色的渐变过程. 包含offset和color两个参数. offset的范围是0 ~ 1, 用于表示位置, color表示颜色 new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, // 100%处的颜色 color: '#f00' }, { offset: 0, // 0%处的颜色 color: '#f99' }]), // 第二个柱状图的颜色填充 new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, // 100%处的颜色 color: 'rgb(249, 173, 21)' }, { offset: 0, // 0%处的颜色 color: 'rgb(255,255,153)' }]) // ... 以此类推 ]} 然后官方上貌似是直接把这个new出来的对象搞成配置项了，下面是官方的写法： 12345678910111213141516171819202122option = { series:[{ color: { type: 'linear', x: 0, // 渐变起始位置横坐标。 y: 0, // 渐变起始位置纵坐标。 x2: 0, // 渐变终止位置横坐标。 y2: 1, // 渐变终止位置纵坐标。 // 组成渐变色的颜色。每个颜色包括 offset 与 color 属性， // 前者表示渐变位置（类型：number），后者表示具体的颜色（类型：string） colorStops: [{ offset: 0, color: 'red' // 0% 处的颜色 }, { offset: 1, color: 'blue' // 100% 处的颜色 }], // 如果为 false，则 colorStops 取值范围是 0 到 1； // 如果为 true，则 x、 y、 x2、 y2、 colorStops 的坐标和元素是一致的 // （也就是说，原先用 1 表示物体最右侧，这时需要用元素实际宽度表示最右侧）。 global: false // 缺省为 false } }]} 不是很清楚哪个好点，但是感觉上应该是直接配置会好点，而不是 new 调用。 径向渐变new渐变色 12345678910111213141516171819202122option = { color: [ // 第一个柱状图的颜色填充，参数依次对应 渐变中心位置横坐标/渐变中心位置纵坐标/渐变半径，默认值为0.5 // 第5个参数则是一个数组 用于配置颜色的渐变过程. 包含offset和color两个参数. offset的范围是0 ~ 1, 用于表示位置, color表示颜色 new echarts.graphic.RadialGradient(0.5, 0.5, 0.5, [{ // ！！！！ 此处是RadialGradient 而不是 LinearGradient offset: 1, // 100%处的颜色 color: '#f00' }, { offset: 0, // 0%处的颜色 color: '#f99' }]), // 第二个柱状图的颜色填充 new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, // 100%处的颜色 color: 'rgb(249, 173, 21)' }, { offset: 0, // 0%处的颜色 color: 'rgb(255,255,153)' }]) // ... 以此类推 ]} 官方文档写法 123456789101112131415161718192021option = { series:[{ color: { type: 'radial', // ！！！！！ 变成了radial x: 0.5, y: 0.5, r: 0.5, // 组成渐变色的颜色。每个颜色包括 offset 与 color 属性， // 前者表示渐变位置（类型：number），后者表示具体的颜色（类型：string） colorStops: [{ offset: 0, color: 'red' // 0% 处的颜色 }, { offset: 1, color: 'blue' // 100% 处的颜色 }], // 如果为 false，则 colorStops 取值范围是 0 到 1； // 如果为 true，则 x、 y、 x2、 y2、 colorStops 的坐标和元素是一致的 // （也就是说，原先用 1 表示物体最右侧，这时需要用元素实际宽度表示最右侧）。 global: false // 缺省为 false } }]} 重置数据渐变消失的问题本次项目中因为需要隔一段时间执行一遍动画（科技感，要动态），所以就写了个计时器清空数据再放进去。 123456789101112timer2 = setInterval(function () { myEcharts.setOption({ // 展示/更新 数据 series:[ { data: [] } ] }) myEcharts.setOption({ // 展示/更新 数据 series:[ { data: that.charsData } ] })}, 6000) 上面这样写在其他图（柱状、饼、漏斗、气泡）里面都是可以正常出来重新加载的过度动画的。但是到了折线图里却没了反应。折线图只有在第一次执行setOption时才有过度动画，之后就没有了，思来想去没想出来啥问题。就避开了这个问题 这里使用了myEcharts.clear()方法清除了当前实例里面的内容(不是销毁)，之后通过重新setOption来放入配置和数据实现动画加载。 然后问题来了，重新加载的图表走的是默认颜色！即使在新的配置里面写渐变色也还是没有起作用人直接傻了，想不通为啥。 解决办法看了看官方文档，发现setOption接收的不止一个参数，他有一个notMerge这个参数，表示了是否不跟之前设置的 option 进行合并。默认为 false。改成true后解决了这个问题。 具体原因还是没搞明白。按理说默认合并也会和数据一样覆盖之前的数据啊，猜测是因为没有用官方写的渐变而是用了new实现，有待测试。 5.Echarts中data和dataset的含义、Echarts数据返回格式Echarts中data和dataset的含义乍一看下data和dataSet好像没什么区别，只是一个需要切割数据到每个series里，一个可以统一使用。但其实在一些特殊情况下，是不支持使用dataSet的。 举个例子：使用 dataset 同时使用 appendData，只支持系列使用自己的 series.data 时使用 appendData。 Data没什么好说的，给那个系列哪个系列就用这组数据。 优点是 直观易理解 适于对一些特殊图表类型进行一定的数据类型定制。 缺点是 为匹配这种数据输入形式，常需要有数据处理的过程,分割到不同系列 此外，不利于多个系列共享一份数据，也不利于基于原始数据进行图表类型、系列的映射安排。 dataset相对于data来说，最直观的就是我们不需要做分割数据的处理。 优点是 能够贴近这样的数据可视化常见思维方式：(I) 提供数据，(II) 指定数据到视觉的映射，从而形成图表。 数据和其他配置可以被分离开来。数据常变，其他配置常不变。分开易于分别管理。 数据可以被多个系列或者组件复用，对于大数据量的场景，不必为每个系列创建一份数据。 支持更多的数据的常用格式，例如二维数组、对象数组等，一定程度上避免使用者为了数据格式而进行转换。 缺点是 可能需要对dataset进行映射，要理解维度和映射的意思。 在部分场景下不适用，比如上面的例子。 根据之前的学习来看，应该是在数据量特别大的时候会用到一些特定的方法，在使用这些方法时不支持与dataset一起使用。假如我们数据量不是很大的情况下，还是dataset会方便好用一点 Echarts数据返回格式data就不用说了吧，主要说下dataset dataset常见的数据格式有下面两种 12345678910111213141516171819202122dataset: { // 提供一份数据。 source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 43.3, 85.8, 93.7], ['Milk Tea', 83.1, 73.4, 55.1], ['Cheese Cocoa', 86.4, 65.2, 82.5], ['Walnut Brownie', 72.4, 53.9, 39.1] ]}dataset: { // 用 dimensions 指定了维度的顺序。直角坐标系中， // 默认把第一个维度映射到 X 轴上，第二个维度映射到 Y 轴上。 // 如果不指定 dimensions，也可以通过指定 series.encode完成映射 dimensions: ['product', '2015', '2016', '2017'], source: [ {product: 'Matcha Latte', '2015': 43.3, '2016': 85.8, '2017': 93.7}, {product: 'Milk Tea', '2015': 83.1, '2016': 73.4, '2017': 55.1}, {product: 'Cheese Cocoa', '2015': 86.4, '2016': 65.2, '2017': 82.5}, {product: 'Walnut Brownie', '2015': 72.4, '2016': 53.9, '2017': 39.1} ] }, 维度和映射维度显然，相对于第一种来说，第二种可读性更高一点。但是第一种的灵活性更高。 我们可以把维度理解为横纵两个方向（不考虑3d图，这个没了解呢哈哈）。 通过一定的配置，我们能够 将横向维度的数据映射到x轴上，纵向的数据叫做横向维度的数据项 将纵向维度的数据映射到x轴上，横向的数据叫做纵向维度的数据项 用第一个例子来帮助理解下： 12345678910111213141516dataset: { // 提供一份数据。 // 横向维度就是每一行，纵向维度就是每一列。 // 在此种数据格式下，我们可以轻松地理解维度的含义。 // 我们可以将这份数据看做一个坐标系，第一列和第一行可以是xy轴(任意) // 后面的数据对应的是x轴和y轴所对应的值 // 比如我把Matcha Latte当为x轴，那么43.3的意义是Matcha Latte在2015年的值 // 或者我把2015当为x轴，那么43.3的意义是在2015年Matcha Latte的值 source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 43.3, 85.8, 93.7], ['Milk Tea', 83.1, 73.4, 55.1], ['Cheese Cocoa', 86.4, 65.2, 82.5], ['Walnut Brownie', 72.4, 53.9, 39.1] ]} 要实现上述更改xy轴的效果，可以使用 seriesLayoutBy 配置项，改变图表对于行列的理解。seriesLayoutBy 可取值： 'column': 默认值。系列被安放到 dataset 的列上面。 'row': 系列被安放到 dataset 的行上面。12345678910111213141516171819202122232425262728293031323334option = { dataset:[ source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 43.3, 85.8, 93.7], ['Milk Tea', 83.1, 73.4, 55.1], ['Cheese Cocoa', 86.4, 65.2, 82.5], ['Walnut Brownie', 72.4, 53.9, 39.1] ] ], xAxis: [ {type: 'category', gridIndex: 0}, {type: 'category', gridIndex: 1} ], yAxis: [ {gridIndex: 0}, {gridIndex: 1} ], grid: [ {bottom: '55%'}, {top: '55%'} ], series: [ // 这几个系列会在第一个直角坐标系中，每个系列对应到 dataset 的每一行。 {type: 'bar', seriesLayoutBy: 'row'}, {type: 'bar', seriesLayoutBy: 'row'}, {type: 'bar', seriesLayoutBy: 'row'}, // 这几个系列会在第二个直角坐标系中，每个系列对应到 dataset 的每一列。 {type: 'bar', xAxisIndex: 1, yAxisIndex: 1}, {type: 'bar', xAxisIndex: 1, yAxisIndex: 1}, {type: 'bar', xAxisIndex: 1, yAxisIndex: 1}, {type: 'bar', xAxisIndex: 1, yAxisIndex: 1} ]} 映射一般通过series.encode来配置映射，效果和上面说的差不多，但是能够指定某列去映射，写个例子大家去官网上瞅瞅吧 1234567891011121314151617181920212223242526272829 var option = { dataset: { source: [ ['score', 'amount', 'product'], [89.3, 58212, 'Matcha Latte'], [57.1, 78254, 'Milk Tea'], [74.4, 41032, 'Cheese Cocoa'], [50.1, 12755, 'Cheese Brownie'], [89.7, 20145, 'Matcha Cocoa'], [68.1, 79146, 'Tea'], [19.6, 91852, 'Orange Juice'], [10.6, 101852, 'Lemon Juice'], [32.7, 20112, 'Walnut Brownie'] ] }, xAxis: {}, yAxis: {type: 'category'}, series: [ { type: 'bar', encode: { // 将 &quot;amount&quot; 列映射到 X 轴。 x: 'amount', // 将 &quot;product&quot; 列映射到 Y 轴。 y: 'product' } } ]};","link":"/2022/10/31/Echarts%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"},{"title":"","text":"GitHubActions安装依赖失败：code EBADPLATFORM解决：删除package-lock.json","link":"/2022/10/31/GitHubActions%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%87%BA%E9%94%99/"},{"title":"Api IntersectionObserver","text":"针对滚动监听的一个小有意思的api IntersectionObserverIntersectionObserver API 是用来监视某个元素是否滚动进了浏览器窗口的可视区域（视口）或者滚动进了它的某个祖先元素的可视区域内。它的主要功能是用来实现延迟加载和展现量统计。 ![img](02 IntersectionObserver.assets/116671-20160605131111086-768036414.png) 它提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root) 构造函数1new IntersectionObserver(callback, options) callback 是个必选参数，当有相交发生时，浏览器便会调用它，后面会详细介绍； options 整个参数对象以及它的三个属性都是可选的： root 根元素，它有很多后代元素，想要做的就是判断它的某个后代元素是否滚动进了自己的可视区域范围。这个 root 参数就是用来指定根元素的，默认值是 null。即浏览器窗口。 需要注意的一点是，如果 root 不是 null，那么相交区域就不一定在视口内了，因为 root 和 target 的相交也可能发生在视口下方 threshold 当目标元素和根元素相交时，用相交的面积除以目标元素的面积会得到一个 0 到 1（0% 到 100%）的数值 ![img](02 IntersectionObserver.assets/116671-20160608175232261-11872166.png) IntersectionObserver API 的基本工作原理就是：当目标元素和根元素相交的面积占目标元素面积的百分比到达或跨过某些指定的临界值时就会触发回调函数。threshold 参数就是用来指定那个临界值的，默认值是 0，表示俩元素刚刚挨上就触发回调。有效的临界值可以是在 0 到 1 闭区间内的任意数值，比如 0.5 表示当相交面积占目标元素面积的一半时触发回调。而且可以指定多个临界值，用数组形式，比如 [0, 0.5, 1]，表示在两个矩形开始相交，相交一半，完全相交这三个时刻都要触发一次回调函数。如果你传了个空数组，它会给你自动插入 0，变成 [0]，也等效于默认值 0。 rootMagin 可以给根元素添加一个假想的 margin，从而对真实的根元素区域进行缩放。比如当 root 为 null 时设置 rootMargin: “100px”，实际的根元素矩形四条边都会被放大 100px ![img](02 IntersectionObserver.assets/116671-20160606131900605-2121804167.png) 实例方法observe()观察某个目标元素，一个观察者实例可以观察任意多个目标元素。注意，这不是事件，没有冒泡。 unobserve()取消对某个目标元素的观察，延迟加载通常都是一次性的，observe 的回调里应该直接调用 unobserve() 那个元素. disconnect()取消观察所有已观察的目标元素 takeRecords() 使用案例很少，不过多说明 理解这个方法需要讲点底层的东西：在浏览器内部，当一个观察者实例在某一时刻观察到了若干个相交动作时，它不会立即执行回调，它会调用 window.requestIdleCallback() （目前只有 Chrome 支持）来异步的执行我们指定的回调函数，而且还规定了最大的延迟时间是 100 毫秒，相当于浏览器会执行 回调函数回调函数共有两个参数，第二个参数就是观察者实例本身，一般没用，因为实例通常我们已经赋值给一个变量了，而且回调函数里的 this 也是那个实例。 第一个参数是个包含有若干个 IntersectionObserverEntry 对象的数组。每个 IntersectionObserverEntry 对象都代表一次相交，它的属性们就包含了那次相交的各种信息。entries 数组中 IntersectionObserverEntry 对象的排列顺序是按照它所属的目标元素当初被 observe() 的顺序排列的。 entries 数组中的实例有如下属性 time 相交发生时距离页面打开时的毫秒数（有小数），也就是相交发生时 performance.now() 的返回值，比如 60000.560000000005，表示是在页面打开后大概 1 分钟发生的相交。在回调函数里用 performance.now() 减去这个值，就能算出回调函数被 requestIdleCallback 延迟了多少毫秒： 1234567&lt;script&gt; let observer = new IntersectionObserver(([entry]) =&gt; { document.body.textContent += `相交发生在 ${performance.now() - entry.time} 毫秒前` }) observer.observe(document.documentElement)&lt;/script&gt; target 相交发生时的目标元素，因为一个根元素可以观察多个目标元素，所以这个 target 不一定是哪个元素 rootBounds 一个对象值，表示发生相交时根元素可见区域的矩形信息，像这样 12345678{ &quot;top&quot;: 0, &quot;bottom&quot;: 600, &quot;left&quot;: 0, &quot;right&quot;: 1280, &quot;width&quot;: 1280, &quot;height&quot;: 600} boundingClientRect 发生相交时目标元素的矩形信息，等价于 target.getBoundingClientRect() intersectionRect 根元素和目标元素相交区域的矩形信息。 intersectionRatio 0 到 1 的数值，表示相交区域占目标元素区域的百分比，也就是 intersectionRect 的面积除以 boundingClientRect 的面积得到的值 实用场景惰性加载（lazy load）123456789101112131415161718function query(selector) { return Array.from(document.querySelectorAll(selector));}var observer = new IntersectionObserver( function(changes) { changes.forEach(function(change) { var container = change.target; var content = container.querySelector('template').content; container.appendChild(content); observer.unobserve(container); }); });query('.lazy-loaded').forEach(function (item) { observer.observe(item);}); 无限滚动（infinite scroll）123456789101112var intersectionObserver = new IntersectionObserver( function (entries) { // 如果不可见，就返回 if (entries[0].intersectionRatio &lt;= 0) return; loadItems(10); console.log('Loaded new items'); });// 开始观察intersectionObserver.observe( document.querySelector('.scrollerFooter'));","link":"/2022/10/31/IntersectionObserverApi/"},{"title":"JavaScript中对this的进一步理解","text":"之前在学习this的时候，总是通过死记硬背来区分各种情况下this的指向，最近在看了 《You Dont Know JS》 后，对其有了进一步的理解 Call-site 和 Call stack即调用点和调用栈。二者并不是一个东西，有一些时机上的差别。调用栈 CallStack 指的是一个记录到当前执行函数为止，记录其顺序的堆栈。调用点 Call-site 指的是当前执行函数之前的调用。 举例说明12345678910111213function baz() { // 调用栈是: `baz` // 调用点是 global scope（全局作用域） console.log( &quot;baz&quot; ); bar(); // &lt;-- `bar` 的调用点}function bar() { // 调用栈是: `baz` -&gt; `bar` // 我们的调用点位于 `baz` console.log( &quot;bar&quot; ); foo(); // &lt;-- `foo` 的 call-site} 调用点是影响this绑定的唯一因素 默认绑定当我们在全局作用域下直接执行函数的时候，this 会进行默认绑定。在非严格模式下，绑定的对象是全局对象，在严格模式下绑定的对象是 undefined。但是需要注意一个细节，即：如果函数的调用点环境是严格模式，即使函数内部没有声明严格模式，全局对象也是唯一合法的。 严格模式下的细节12345678function foo() { console.log( this.a );}var a = 2;(function(){ &quot;use strict&quot;; foo(); // 2})(); 有时你可能会引用与你的 Strict 模式不同的第三方包，所以对这些微妙的兼容性细节要多加小心 隐含绑定当函数被声明作为引用属性添加到obj上时，并不代表这个对象真正拥有或包含这个函数，但调用点通过obj环境来引用函数，所以可以说obj对象在函数被调用的事件点上拥有或包含这个函数引用。 当一个方法引用存在一个环境对象时，隐含绑定 规则会说：是这个对象应当被用于这个函数调用的 this 绑定。因为 obj 是 foo() 调用的 this，所以 this.a 就是 obj.a 的同义词，同时，只有对象属性引用链的最后一层是影响调用点的 隐式绑定123456789101112function foo() { console.log( this.a );}var obj2 = { a: 42, foo: foo};var obj1 = { a: 2, obj2: obj2};obj1.obj2.foo(); // 42 隐含丢失下面的代码会造成绑定的丢失12345678910function foo() { console.log( this.a );}var obj = { a: 2, foo: foo};var bar = obj.foo; // 函数引用！var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性bar(); // &quot;oops, global&quot; 尽管 bar 似乎是 obj.foo 的引用，但实际上它只是另一个 foo 本身的引用而已。起到绑定作用的是 默认绑定。上面的情况在我们将函数当作参数传递时，也会发生。因为传递函数的时候，是一个隐含的引用赋值。 明确绑定明确绑定指的是通过 call、apply 调用函数。二者除了参数格式不同，没什么太大区别，都允许我们传入this要绑定的对象。 如果传递一个简单基本类型值（string，boolean，或 number 类型）作为 this 绑定，那么这个基本类型值会被包装在它的对象类型中（分别是 new String(..)，new Boolean(..)，或 new Number(..)）。这通常称为“封箱（boxing）”。 硬绑定单独使用 明确绑定 无法解决三方框架覆盖this、丢失自己原本的this绑定等问题。但是有一个 明确绑定 的变种确实可以实现这个技巧。 1234567891011121314function foo() { console.log( this.a );}var obj = { a: 2};var bar = function() { foo.call( obj );};bar(); // 2setTimeout( bar, 100 ); // 2// `bar` 将 `foo` 的 `this` 硬绑定到 `obj`// 所以它不可以被覆盖bar.call( window ); // 2 用 硬绑定 将一个函数包装起来的最典型的方法，是为所有传入的参数和传出的返回值创建一个通道，通过 apply 绑定this，并将 arguments 参数列表返回。 123456789101112function foo(something) { console.log( this.a, something ); return this.a + something;}var obj = { a: 2};var bar = function() { return foo.apply( obj, arguments );};var b = bar( 3 ); // 2 3console.log( b ); // 5 也可以实现bind函数 简单的bind函数123456// 简单的 `bind` 帮助函数function bind(fn, obj) { return function() { return fn.apply( obj, arguments ); };} 在 ES6 中，bind(..) 生成的硬绑定函数有一个名为 .name 的属性，它源自于原始的 目标函数（target function） new 绑定 this需要明确一点，JavaScript通过new运算符操作的函数并不是严格意义上的构造器，它仅仅是一个函数。可以说是我们通过构造器的方法去调用了这个函数，改变了函数的行为。例如Number()函数，在直接调用和new时会有不同的行为 当在函数前面被加入 new 调用时，也就是构造器调用时，下面这些事情会自动完成： 一个全新的对象会凭空创建（就是被构建） 这个新构建的对象会被接入原形链（[[Prototype]]-linked） 这个新构建的对象被设置为函数调用的 this 绑定 除非函数返回一个它自己的其他 对象，否则这个被 new 调用的函数将 自动 返回这个新构建的对象。 上述几种规则的优先顺序当调用点同时满足上述几种规则时，会有如下优先级 new &gt; 硬绑定（明确绑定） &gt; 隐含绑定 &gt; 默认绑定 当然我们无法同时使用 new 和 call/apply ，但是我们能够通过硬绑定去测试二者的优先级 通过硬绑定比较优先级12345678910111213function foo(something){ this.a = something;}var obj1 = {};var bar = foo.bind(obj1);bar(2);console.log(obj1.a); // 2var baz = new bar(3);console.log(obj1.a); // 2console.log(baz.a); // 3 可以看到，new覆盖了硬绑定的this 一些特列null 和 undefined当传递 null 或 undefined 作为 call、apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用 间接当创建函数引用时，默认绑定规则也会适用 赋值12345678function foo() { console.log( this.a );}var a = 2;var o = { a: 3, foo: foo };var p = { a: 4 };o.foo(); // 3(p.foo = o.foo)(); // 2 赋值表达式 p.foo = o.foo 的 结果值 是一个刚好指向底层函数对象的引用 箭头函数箭头函数从封闭它的（函数或全局）作用域采用 this 绑定。一个箭头函数的词法绑定是不能被覆盖的（就连 new 也不行！）","link":"/2022/09/05/JavaScript%E4%B8%AD%E5%AF%B9this%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3/"},{"title":"JavaScript垃圾回收机制","text":"针对JavaScript垃圾回收机制的深入学习 前置知识堆栈栈什么是栈栈其实是一种数据结构，有着先进后出，后进先出的特性，用生活中的事物来理解最形象的就是汉诺塔了。我们在栈中存储的数据就像汉诺塔的盘子一样，最先放进去在最下面，最后放入的盘子在最上面。我们想拿数据的时候，也需要从塔顶开始拿，也就是最后放入的开始，上面的拿完才能拿下面的。 下图可以看做有三个栈 简而言之，我们可以将栈理解为一个具有先进后出，后进先出特点的存储空间，对于JavaScript来说，它会把基本数据类型放入栈内存储。 堆什么是堆当我们创建一个对象的时候，实际上会在堆空间开辟一个空间，我们声明的变量保存的其实是堆空间的地址简而言之，堆空间是存放复杂数据类型的存储空间，我们通过变量存储的其实是这些数据在堆空间内的地址。 当我们将一个本来存有地址的变量设置为null时，本质上是将该变量与堆空间的联系斩断，但堆空间内仍存有之前的复杂数据类型。只有当垃圾回收机制执行时，才会将这些没有人引用的复杂数据类型销毁，释放出堆空间。 执行上下文与作用域链执行上下文在JavaScript中有三种上下文 全局执行上下文：Global CodeJavaScript代码开始运行的默认环境 函数执行上下文：Function Code存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。 Eval 函数执行上下文： 使用eval()执行代码，因为很少用所以本次不做讨论。 在JavaScript代码执行的过程中，默认进入的总是全局执行上下文，JavaScript会把其存入上下文栈中去，每当遇到定义的函数被执行，便会创建一个新的执行上下文，并将其存入上下文栈中去。 当一个函数执行完毕后，上下文栈会将其弹出，将上下文环境交还给上个函数。 作用域链上下文栈会根据栈内的顺序形成一条作用域链，用来控制变量的访问。处于上层作用域链的函数内部无法访问下层作用域链的变量。 下层作用域链中的函数可以访问上层作用域链的对象，若上层也没有，则再向上查找，直到全局作用域也没有，则返回null。 一、JavaScript中怎么被定义为垃圾使用局部变量123456789function makeTrash(){ var a = 1;}// 在makeTrash执行时，会创建a这个变量。// 此时栈空间会为其分配一块区域供其存储。makeTrash();// 函数执行完后，由于不再需要变量a，所以此时的a便成为了垃圾// 栈空间将会释放之前为a分配的空间。// 至此，垃圾回收完毕 使用对象123456789// 此时的obj指向堆内存中创建的一块空间var obj = { name:'ZhangSan', age:'18'}obj = null// 当我们对其赋值为null的时候，obj与堆内存中的空间的关系被斩断。// 由于堆内存中的空间没有人引用，所以这块空间就成了JavaScript中所谓的的垃圾 概括凡是未被引用的变量或对象，都会被视为垃圾。 可能成为垃圾的特例全局变量由于全局对象window的销毁一般发生在页面卸载时，所以对于全局变量是否为垃圾很难进行判断，所以要尽量少用全局变量，或在用完设置为null。闭包在闭包中，由于返回的函数对于变量持有引用，垃圾回收机制也无法对外层函数中被引用的变量进行回收，所以需要手动把接收闭包返回值的对象设置为null。 二、两种回收策略JavaScript中垃圾回收机制的策略分为两种 标记清理 引用计数 标记清理当变量进入上下文时，会对其添加上 存在于上下文 的标记。当变量退出上下文时，对退出上下文的变量添加上退出上下文的标记 例如在一个函数中声明一个变量，该变量就会被标记为存在于上下文中。当函数执行完毕，上下文栈弹出该函数的上下文，其内变量添加 退出上下文的标记。 此种策略的垃圾回收机制在运行的时候，会对所有已存在于内存的变量进行标记。 之后垃圾回收机制会清除上下文中所有变量的标记，包括其引用的变量的标记也会在此被清除。 最后仍然被标记的变量，即为要回收的垃圾。因为没有地方引用他们。 引用计数该种策略会对每个值记录它被引用的次数。声明变量并给他赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，则引用次数+1。 类似的，如果保存对该值引用的变量被其他值给覆盖了，那么引用数-1。 当一个值的引用数为0时，就说明没有办法在访问到这个值了。此时被判断为垃圾，在下次垃圾回收机制执行时会释放引用值为0的值所占用的内存。 概括本质上都是找到未被引用的值，从而在垃圾回收执行时释放其空间。 三、什么时候执行垃圾回收不同浏览器的引擎执行垃圾回收的时机也不一样。 根据网上查阅的资料来看，对于大部分浏览器的引擎来说，我们无法人为的去控制什么时候进行垃圾回收，因为js并没有暴露出相关的接口供我们调用。 我们在MDN中可以看到一些相关的说明 不再需要内存时释放大多数内存管理问题发生在这个阶段。此阶段最困难的方面是确定何时不再需要分配的内存。 低级语言要求开发人员手动确定程序中哪个点不再需要分配的内存并释放它。 一些高级语言，例如 JavaScript，使用一种称为垃圾收集 (GC) 的自动内存管理形式。垃圾收集器的目的是监控内存分配并确定何时不再需要分配的内存块并回收它。这个自动过程是一个近似值，因为确定是否仍然需要特定内存的一般问题是不可判定的。 在拥有了两种垃圾回收策略后，执行的周期性不再是问题，因为我们能够将垃圾明确出来，只需要等下次回收即可。 周期不再是问题 123456789function f() {var x = {};var y = {};x.a = y; // x references yy.a = x; // y references xreturn 'azerty';&gt;}&gt;f(); 在上面的示例中，函数调用返回后，这两个对象不再被可从全局对象访问的任何资源引用。因此，垃圾收集器将发现它们无法访问并回收分配的内存。 关于Chrome V8引擎的GC分代回收绝大多数对象的生存期很短，只有某些对象的生存期较长。为利用这一特点，V8将堆进行了分区： 新生区：大多数对象被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立。 老生指针区：这里包含大多数可能存在指向其他对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里。 老生数据区：这里存放只包含原始数据的对象（这些对象没有指向其他对象的指针）。字符串、封箱的数字以及未封箱的双精度数字数组，在新生区存活一段时间后会被移动到这里。 大对象区：这里存放体积超越其他区大小的对象。每个对象有自己mmap产生的内存。垃圾回收器从不移动大对象。 代码区：代码对象，也就是包含JIT之后指令的对象，会被分配到这里。这是唯一拥有执行权限的内存区（不过如果代码对象因过大而放在大对象区，则该大对象所对应的内存也是可执行的。译注：但是大对象内存区本身不是可执行的内存区）。 Cell区、属性Cell区、Map区：这些区域存放Cell、属性Cell和Map，每个区域因为都是存放相同大小的元素，因此内存结构很简单。 回收的执行周期对象起初会被分配在新生区（通常很小，只有1-8 MB，具体根据行为来进行启发）。在新生区的内存分配非常容易：我们只需保有一个指向内存区的指针，不断根据新对象的大小对其进行递增即可。当该指针达到了新生区的末尾，就会有一次清理（小周期），清理掉新生区中不活跃的死对象。 对于活跃超过2个小周期的对象，则需将其移动至老生区。老生区在标记－清除或标记－紧缩（大周期）的过程中进行回收。大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。至于足够多到底是多少，则根据老生区自身的大小和程序的动向来定。 Scavenge算法V8采用了Scavenge算法，是按照Cheney的算法实现的。 算法的大致流程为：将新生区划分为**入区(from-space)和出区(to-space)**。绝大多是内存分配是在出区进行，而当出区被填满时，我们会交换出区和入区，然后将入区中活跃的对象复制至出区或老生区当中。在这时我们会对活跃对象进行紧缩，以便提升Cache的内存局部性，保持内存分配的简洁快速。上图描述了在新生区中，如何回收的垃圾b。 而当一个变量在两次从入区(from-space) 移动到 出区(to-space) 时。他就会被提升到老生区的内存空间中 注意，在上面的回收过程中，为了避免有老生区的变量指向新生区，但在新生区的清理周期中被引用的变量被错误回收，V8引擎做了额外的处理：写屏障 写屏障肯定不可能通过遍历老生区去查找到底哪个变量引用了新生区的变量，耗时太大。所以通过在写缓冲区中创建一个列表去记录所有老生区对象指向新生区的情况，这样就可以避免上述错误回收。该记录行为总是发生在写操作的时候，每个写操作都会经历这么一关。 老生区在老生区中，用到的是上文我们说过的标记清理法结合标记紧缩法去回收。 标记清理法是如何标记的V8 使用每个对象的两个 mark-bits 和一个标记工作表来实现标记。两个 mark-bits 编码三种颜色：白色（00），灰色（10）和黑色（11）。 如果一个对象的状态为白，那么它尚未被垃圾回收器发现，同时最开始所有对象都是白色如果一个对象的状态为灰，那么它已被垃圾回收器发现，但它的邻接对象仍未全部处理完毕如果一个对象的状态为黑，则它不仅被垃圾回收器发现，而且其所有邻接对象也都处理完毕 算法的核心实际是深度优先搜索，从根（Root）可达的对象会被染为灰色，并放入标记用的一个单独分配的双端队列。标记阶段的每次循环，GC会将一个对象从双端队列中取出，染为黑色，然后将它的邻居对象染为灰色，并把邻居对象放入双端队列。这一过程在双端队列为空且所有对象都变黑时结束。 特别大的对象，如长数组，可能会在处理时分片，以防溢出双端队列。如果双端队列溢出了，则对象仍然会被染为灰色，但不会再被放入队列（这样他们的邻接对象就没有机会再染色了）。因此当双端队列为空时，GC仍然需要扫描一次，确保所有的灰对象都成为了黑对象。对于未被染黑的灰对象，GC会将其再次放入队列，再度处理。 标记算法结束时，所有的活跃对象都被染为了黑色，而所有的死对象则仍是白的。 对于深度优先和广度优先可以看看算法图解，画的挺形象的。 标记紧缩法 在使用完标记清理法后，确实能够将垃圾清理掉，但是清理后的空间是不连续的。而一些数据的存储要求的是连续的空间，所以这时候就需要用标记紧缩法去整理碎片空间。 达到这种效果 增量标记法当一个堆很大而且有很多活跃对象时，标记-清除和标记-紧缩算法会执行的很慢，又因为垃圾回收机制在执行时会阻塞js代码(JS是单线程的)，所以在2012年年中，谷歌引入了增量标记和惰性清理两项技术。 增量标记允许堆的标记发生在几次5-10毫秒（移动设备）的小停顿中。增量标记在堆的大小达到一定的阈值时启用。启用后每当一定量的内存分配后，脚本就会停顿一次用来执行标记，同样是黑白灰三色，也同样是深度优先搜索。 写屏障和上文提到过的写屏障类似，为了避免出现黑色指向白色这种情况出现，我们通过写屏障记录黑色指向白色的指针，一旦发现这种指针，就会将黑色对象重新染色为灰色对象，重新放回到双端队列中。当算法将该对象取出时，其包含的指针会被重新扫描，这样活跃的白对象就不会漏掉。 惰性清理因为所有对象已被处理，因此非死即活。谁是垃圾已经很明确了，所以不用着急释放空间，延迟一下清理也可以。 效果类似下图所示 上面的是完整的GC执行，下方的是增量标记法与惰性清理的执行。当清理完后，即可随时开始再一次的标记。这样就能减少明显的停顿 并发标记与并行标记并发标记支持在主线程进行GC的时候启动多个worker thread一起执行GC。应用程序在整个并发标记阶段暂停，它是 stop-the-world 标记的多线程版本。 并行标记则是在主线程还在运行时即可启动多个worker thread执行GC，应用程序可以继续运行。 具体细节可参考引擎V8推出“并发标记”，可节省60%-70%的GC时间 四、内存问题内存泄漏什么是内存泄漏？ 内存泄漏指的是在执行垃圾回收的时候， 由于一些原因导致本应释放掉的空间没有被释放掉。 常见的内存泄漏循环引用在浏览器早起采用引用计数法的时候，如果两个变量相互引用，则其引用数始终为1，而垃圾回收只会对引用数为0的变量进行回收，这时就导致了内存泄漏。这也是为什么现在大都采用的标记清理法 没有被销毁的全局变量和计时器123456789101112function fn(){ bar = 'bar'; // 声明了全局变量}fn();var timer = getStart();getStart(function() { var temp = document.getElementById('temp'); if(temp) { temp.innerHTML = JSON.stringify(temp); }}, 5000); // 每5秒调用一次 此时若不手动置为null/调用clearInterval，则该变量和计时器将会一直存在，造成内存泄漏。直到window对象被销毁。 闭包1234567var closure = function(){ var count = 0; return function(){ return count++ }}const fn = closure(); 由于被返回的函数一直持有其外层函数closure的变量count导致count无法被回收，造成内存泄漏。所以能少用闭包就少用，或者用完及时置为null。 内存溢出内存溢出是一种程序运行的错误。指的是当程序运行需要的内存超过了剩余内存的时候，就会抛出内存溢出的错误。 内存泄漏积累过多时，就会导致内存溢出。 频繁的垃圾回收通过上文我们可以知道，早期的垃圾回收是单线程的，执行时会引起主线程的停顿。过于频繁的垃圾回收会造成程序的卡顿。 后来加入的并行标记和并发标记都是为了解决这个主线程卡顿的问题，但是否被现在的主流浏览器采用还是不太清楚。 五、Es6 WeakMap为了解决内存泄漏这个问题，ES6添加了WeakMap和WeakSet两个数据结构。他们对于值的引用都是不计入垃圾回收机制的，所以名字里才会有一个Weak，表示弱引用。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 参考文章 【译】V8 之旅： 垃圾回收器（想了解细节方面的可以看看） 原文（翻译的看起来可能会有些不易理解，建议结合起来看） javascript垃圾回收机制 JavaScript执行机制之垃圾回收 引擎V8推出“并发标记”，可节省60%-70%的GC时间 JavaScript 内存管理以及垃圾回收机制（引用计数、标记清除） 图解 JavaScript 垃圾回收 — 现代 JavaScript 教程 MDN","link":"/2022/10/31/JavaScript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"title":"TypeScript函数","text":"针对函数的部分，做了如下的回顾 函数类型表达式用于描述函数参数类型、返回值。 12345678function greeter(fn: (a: string) =&gt; void) { fn(&quot;Hello, World&quot;);}// 也可以用别名type GreetFunction = (a: string) =&gt; void;function greeter(fn: GreetFunction) { // ...} 调用签名用于用属性描述函数可调用的东西，可以在对象类型中编写调用签名 1234567type DescribableFunction = { description: string; (someArg: number): boolean;};function doSomething(fn: DescribableFunction) { console.log(fn.description + &quot; returned &quot; + fn(6));} 与函数类型表达式相比，在参数列表和返回值之间使用了:而不是=&gt; 构造签名通过在调用签名前添加关键字new来编写构造签名 123456type SomeConstructor = { new (s: string): SomeObject;};function fn(ctor: SomeConstructor) { return new ctor(&quot;hello&quot;);} 泛型函数描述某一类参数、返回值类型相同的函数。当想要描述参数与返回值的关系时，可通过泛型指定 123function firstElement&lt;Type&gt;(arr: Type[]): Type | undefined { return arr[0];} 推断ts可以自动根据参数类型推断出返回值的类型 1234567function map&lt;Input, Output&gt;(arr: Input[], func: (arg: Input) =&gt; Output): Output[] { return arr.map(func);} // Parameter 'n' is of type 'string'// 'parsed' is of type 'number[]'const parsed = map([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], (n) =&gt; parseInt(n)); TypeScript 可以推断Input类型参数的类型（从给定的string数组），以及Output基于函数表达式的返回值的类型参数 ( number) 约束指的就是对类型或属性的限制。在 想关联两个值，但只能对某个值的子集进行操作 时可以用到 1234567function longest&lt;Type extends { length: number }&gt;(a: Type, b: Type) { if (a.length &gt;= b.length) { return a; } else { return b; }} 上述的extends就是子句，用于当我们无法直接操作Type类型的情况 还需要注意一个常见的错误：函数承诺返回与传入相同类型的对象，而不仅仅是与约束匹配的某个对象。 可选参数通过?声明可选参数。可选参数可以接收undefined。 可以声明默认参数 fn(x=10) 回调中的可选参数为回调编写函数类型时，切勿编写可选​​参数，除非打算在不传递该参数的情况下调用该函数 1234567891011function myForEach(arr: any[], callback: (arg: any, index?: number) =&gt; void) { for (let i = 0; i &lt; arr.length; i++) { // I don't feel like providing the index today callback(arr[i]); }}myForEach([1, 2, 3], (a, i) =&gt; { console.log(i.toFixed());// Object is possibly 'undefined'.}); 上述报错显示i可能为undefined，但实际是不可能出现的错误 函数重载在 TypeScript 中，我们可以通过编写重载签名来指定一个可以以不同方式调用的函数。为此，请编写一些函数签名（通常是两个或更多），然后是函数的主体： 1234567891011121314function makeDate(timestamp: number): Date;function makeDate(m: number, d: number, y: number): Date;function makeDate(mOrTimestamp: number, d?: number, y?: number): Date { if (d !== undefined &amp;&amp; y !== undefined) { return new Date(y, mOrTimestamp, d); } else { return new Date(mOrTimestamp); }}const d1 = makeDate(12345678);const d2 = makeDate(5, 5, 5);const d3 = makeDate(1, 3); 前两个签名称为重载签名。然后，我们编写了一个具有兼容签名的函数实现。函数有一个实现签名，但是这个签名不能直接调用。即使我们在必需的参数之后编写了一个带有两个可选参数的函数，也不能用两个参数调用它！ 实现签名还必须与重载签名兼容 尽可能使用联合类型的参数而不是重载 this 在函数中声明JavaScript 规范声明你不能有一个名为 this 的参数，因此 TypeScript 使用该语法空间让你在函数体中声明 this 类型 1234567891011121314151617const user = { id: 123, admin: false, becomeAdmin: function () { this.admin = true; },};interface DB { filterUsers(filter: (this: User) =&gt; boolean): User[];} const db = getDB();const admins = db.filterUsers(function (this: User) { return this.admin;}); 其他的一些类型 void无返回值 unknown表示任何值，类似与any，但比any更安全。因为用unknown做任何事情都是不合法的 never示从未观察到的值，意味着达不到的意思。在函数返回类型中，这意味着函数抛出异常或终止程序的执行 Function全局类型Function描述了 JavaScript 中所有函数值上的属性，如bind、call、apply和其他属性 object特殊类型object是指任何不是原始值（string、number、bigint、boolean、symbol、null或undefined）的值。这与空对象类型 { }不同，也与全局类型不同Object。很可能永远不会使用Objectobject不是Object。一直用object！ 剩余参数和参数rest 参数出现在所有其他参数之后，并使用…语法 123function multiply(n: number, ...m: number[]) { return m.map((x) =&gt; n * x);} 通常，TypeScript 并不假定数组是不可变的。即展开运算符扩展的是一个以上的参数，而不是具体的几个参数 123const args = [8, 5];const angle = Math.atan2(...args);// A spread argument must either have a tuple type or be passed to a rest parameter. 错误提示需要两个参数，正在用“0或更多”参数调用Math.atan2()。这种情况的最佳解决方案取决于代码，但一般来说，const上下文是最直接的解决方案 1234// Inferred as 2-length tupleconst args = [8, 5] as const;// OKconst angle = Math.atan2(...args); 通过使用as const，将args数组变为了定长的只读数组，防止了报错 参数解构12345function sum({ a, b, c }: { a: number; b: number; c: number }) { console.log(a + b + c);}","link":"/2022/09/12/TypeScript%20%E5%87%BD%E6%95%B0/"},{"title":"TypeScript常见类型","text":"最近看了一些ts的语法，觉得有点陌生，经过一番搜索发现之前看的中文文档版本落后了很多。。。嗨，现在对着英文文档再回顾一下吧 基本数据类型string、number、boolean 类型名 String ，Number 和 Boolean （首字母大写）也是合法的，但它们是一些非常少见的特殊内置类型。所以类型总是使用 string ，number 或者 boolean 。 数组声明方式：number[]、Array&lt;number&gt;。在jsx语法中只能使用前者 any当不指定类型时，并且ts无法从上下文中推断出该类型时，编译器通常会默认为any 变量的类型注释指声明变量时指定该变量的类型，例如let a:string = '字符串' 函数ts允许指定函数输入和输出值的类型通过参数类型注解指定输入类型，通过函数返回类型注解指定函数返回值类型 123function getString(str:string):string{ return str;} 匿名函数当一个函数出现在 TypeScript 可以确定如何调用它的地方时，该函数的参数会自动被赋予类型这个过程称为上下文类型，因为函数发生的上下文告知它应该具有什么类型，例如foreach中的callback函数 对象类型只需列出其属性和类型 可选属性在属性后面加?表明该属性可选当从可选属性中读取属性时，需要先判断不是undefined 联合类型通过|定义，表明该类型是指定类型的其中之一但在访问属性时，仅允许访问二者属性的交集。 12345function printId(id: number | string) { console.log(id.toUpperCase());//Property 'toUpperCase' does not exist on type 'string | number'. //Property 'toUpperCase' does not exist on type 'number'.} 需要我们收窄范围，即通过条件语句判断类型，再访问属性 别名类型指type，不仅能为对象类型使用，任何类型都能使用。例如type ID = number | string; 别名 只是 别名，不能使用类型别名创建同一类型的不同“版本” 接口接口声明 是命名对象类型的另一种方式 类型别名和接口之间的区别类型别名和接口非常相似，在大多数情况下你可以在它们之间自由选择。 几乎所有的 interface 功能都可以在 type 中使用，关键区别在于不能重新开放类型以添加新的属性，而接口始终是可扩展的 interface type 扩展接口 通过extends关键字继承接口 通过&amp;扩展类型 添加新字段 重新声明接口直接写 无法添加 在 TypeScript 4.2 之前，类型别名命名 可能 会出现在错误消息中，有时代替等效的匿名类型（可能需要也可能不需要）。接口在错误消息中将始终被命名。 类型别名不能参与 声明合并，但接口可以。 接口只能用于 声明对象的形状，不能重命名基本类型. 接口名称将 始终 以其原始形式出现 在错误消息中，但 只有 在按名称使用时才会出现。 类型断言有时你会得到关于 TypeScript 无法知道的值类型的信息。 例如，如果您正在使用document.getElementById，TypeScript 只知道这将返回某种，HTMLElement但您可能知道您的页面将始终具有HTMLCanvasElement具有给定 ID 的 。 通过as或&lt;&gt;断言(jsx语法中只能用前者) 12const myCanvas = document.getElementById(&quot;main_canvas&quot;) as HTMLCanvasElement;const myCanvas = &lt;HTMLCanvasElement&gt;document.getElementById(&quot;main_canvas&quot;); TypeScript 只允许类型断言转换为更具体或更不具体的类型版本。此规则可防止“不可能”的强制，例如将string类型断言为number时，会报错但是可以通过连用as实现上述操作： 1const a = expr as any as T; 文字类型声明一个变量让其等于指定值。let x: &quot;hello&quot; = &quot;hello&quot;;可以通过联合类型组合文字类型，使其只接受一组值中的一个 123456function printText(s: string, alignment: &quot;left&quot; | &quot;right&quot; | &quot;center&quot;) { // ...}printText(&quot;Hello, world&quot;, &quot;left&quot;);printText(&quot;G'day, mate&quot;, &quot;centre&quot;);// Argument of type '&quot;centre&quot;' is not assignable to parameter of type '&quot;left&quot; | &quot;right&quot; | &quot;center&quot;'. boolean本身也是union的别名，true|false 字面推理当使用对象初始化变量时，TypeScript 假定该对象的属性可能会在以后更改值 有两种方法可以解决这个问题 通过在任一位置添加类型断言来更改推理1234// Change 1:const req = { url: &quot;https://example.com&quot;, method: &quot;GET&quot; as &quot;GET&quot; };// Change 2handleRequest(req.url, req.method as &quot;GET&quot;); 更改 1 的意思是“我打算req.method始终拥有文字类型 “GET””，从而防止之后可能分配”GUESS”给该字段。更改 2 的意思是“我知道有其他req.method价值的原因”GET””。 用 as const将整个对象转换为类型文字： 12const req = { url: &quot;https://example.com&quot;, method: &quot;GET&quot; } as const;handleRequest(req.url, req.method); as const 后缀的作用类似于 const，但用于类型系统，确保为所有属性分配文字类型，而不是更通用的版本，如字符串或数字。 null 和 undefinedJavaScript 有两个原始值用于表示不存在或未初始化的值：null和undefined. 当strictNullChecks关闭的时候，等于是对null和undefined没有检查打开时，当一个值为null或undefined时，您需要在对该值使用方法或属性之前测试这些值。就像undefined在使用可选属性之前检查一样，我们可以使用缩小来检查可能是的值null 非空断言运算符 !通过再表达式后面写!来表示该值不是null或undefined 两个感叹号!!表示 一个狭窄的文字布尔类型 true!!&quot;world&quot;; // type: true, value: true","link":"/2022/09/07/TypeScript%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"TypeScript对象类型","text":"针对对象的部分，做了如下的回顾 对象属性的三种描述方法： 通过对象本身的key value 通过接口 通过类型别名 属性修饰符对象中的属性可以指定如下几件事： 是否可选 是否只读 属于什么类型 可选修饰符 ?通过?修饰符表示属性可选。当开启strictNullChecks时，会提示潜在的错误 123456789function paintShape(opts: PaintOptions) { let xPos = opts.xPos; // (property) PaintOptions.xPos?: number | undefined let yPos = opts.yPos; // (property) PaintOptions.yPos?: number | undefined // ...} 解决undefined的问题，有两种方法 手动判断是否为undefined 赋默认值(通过解构函数参数赋默认值) 注意，目前没有办法在解构模式中放置类型注释。因为在 JavaScript 中，下面的语法代表的意思完全不同 123456function draw({ shape: Shape, xPos: number = 100 /*...*/ }) { render(shape); // Cannot find name 'shape'. Did you mean 'Shape'? render(xPos); // Cannot find name 'xPos'.} 在对象解构语法中，shape: Shape 表示的是把 shape 的值赋值给局部变量 Shape。 xPos: number 也是一样，会基于 xPos 创建一个名为 number 的变量。 只读修饰符 readonly对于使用readonly的属性，在运行时不会影响任何行为，但在类型检查时不允许写入readonly仅表示属性本身不能重新写入，并不等于完全不会发生改变(可以对比const声明的对象理解) TypeScript 在检查两个类型是否兼容的时候，并不会考虑两个类型里的属性是否是 readonly，这就意味着，readonly 的值是可以通过别名修改的 123456789101112131415161718192021interface Person { name: string; age: number;} interface ReadonlyPerson { readonly name: string; readonly age: number;} let writablePerson: Person = { name: &quot;Person McPersonface&quot;, age: 42,}; // workslet readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // prints '42'writablePerson.age++;console.log(readonlyPerson.age); // prints '43' 索引签名适用于不知道key值，但知道key值的类型 12345678interface StringArray { [index: number]: string;} const myArray: StringArray = getStringArray();const secondItem = myArray[1]; const secondItem: string 这个索引签名表示当一个 StringArray 类型的值使用 number 类型的值进行索引的时候，会返回一个 string类型的值 一个索引签名的属性类型必须是 string 或者是 number 由于js会隐式的将数字索引转为字符串，所以数字索引返回的类型一定是字符串索引返回的子类型 1234567891011121314interface Animal { name: string;} interface Dog extends Animal { breed: string;} // Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay { [x: number]: Animal; // 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. [x: string]: Dog;} 通过给索引签名设置只读属性，可以控制赋值行为 1234567interface ReadonlyStringArray { readonly [index: number]: string;} let myArray: ReadonlyStringArray = getReadOnlyStringArray();myArray[2] = &quot;Mallory&quot;;// Index signature in type 'ReadonlyStringArray' only permits reading. 属性继承通过extends关键字继承接口interface A extends B 交叉类型通过&amp;合并两个类型 接口继承与交叉类型通过接口继承的方式去重写某个属性会报错，但是交叉类型不会报错。 1234567interface Colorful { color: string;}type ColorfulSub = Colorful &amp; { color: number} 虽然不会报错，那 color 属性的类型是什么呢，答案是 never，取得是 string 和 number 的交集 泛型对象类型可以理解为一种延迟指定的类型，只有在实例化时才会作为参数指明类型 123interface Box&lt;Type&gt; { contents: Type;} 可以通过泛型函数来避免函数的重载 123function setContents&lt;Type&gt;(box: Box&lt;Type&gt;, newContents: Type) { box.contents = newContents;} 数组类型类型 number[] 或者 string[] 只是 Array&lt;number&gt; 和 Array&lt;string&gt; 的简写形式而已 Array 本身就是一个泛型 123456789101112131415161718interface Array&lt;Type&gt; { /** * Gets or sets the length of the array. */ length: number; /** * Removes the last element from an array and returns it. */ pop(): Type | undefined; /** * Appends new elements to an array, and returns the new length of the array. */ push(...items: Type[]): number; // ...} ReadonlyArray 类型是一个特殊类型，它可以描述数组不能被改变,主要是用来做意图声明。用于让使用者放心传入数组或禁止使用者更改数组 123456789function doStuff(values: ReadonlyArray&lt;string&gt;) { // We can read from 'values'... const copy = values.slice(); console.log(`The first value is ${values[0]}`); // ...but we can't mutate 'values'. values.push(&quot;hello!&quot;); // Property 'push' does not exist on type 'readonly string[]'.} ReadonlyArray 并不是一个我们可以用的构造器函数，但可以直接把一个常规数组赋值给 ReadonlyArrayTypeScript 也针对 ReadonlyArray&lt;Type&gt; 提供了更简短的写法 readonly Type[] 123456789function doStuff(values: readonly string[]) { // We can read from 'values'... const copy = values.slice(); console.log(`The first value is ${values[0]}`); // ...but we can't mutate 'values'. values.push(&quot;hello!&quot;); // Property 'push' does not exist on type 'readonly string[]'.} Arrays 和 ReadonlyArray 并不能互相赋值 元组类型是另外一种 Array 类型。适用于元素个数和类型已知。type StringNumberPair = [string, number]; 可以解构元组12345function doSomething(stringHash: [string, number]) { const [inputString, hash] = stringHash; console.log(inputString); // const inputString: string console.log(hash); // const hash: number} 可选属性会影响类型的length 可以使用剩余元素语法，但必须是array或tuple（元组）类型有剩余元素的元组并不会设置 length 可选元素和剩余元素可以使ts在参数列表里使用元组1234function readButtonInput(...args: [string, number, ...boolean[]]) { const [name, version, ...input] = args; // ...} readonly 元组类型（readonly Tuple Types）元组类型也是可以设置 readonly，TypeScript 不会允许写入 readonly 元组的任何属性 123function doSomething(pair: readonly [string, number]) { // ...} 在大部分的代码中，元组只是被创建，使用完后也不会被修改，所以尽可能的将元组设置为 readonly 是一个好习惯 如果我们给一个数组字面量 const 断言，也会被推断为 readonly 元组类型 1234567891011let point = [3, 4] as const; function distanceFromOrigin([x, y]: [number, number]) { return Math.sqrt(x ** 2 + y ** 2);} distanceFromOrigin(point);// Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.// The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'. 尽管 distanceFromOrigin 并没有更改传入的元素，但函数希望传入一个可变元组。因为 point 的类型被推断为 readonly [3, 4]，它跟 [number number] 并不兼容，所以 TypeScript 给了一个报错。","link":"/2022/09/19/TypeScript%20%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/"},{"title":"TypeScript收窄","text":"简单来说就是类型过滤，能够缩窄类型的范围 typeof可以通过typeof返回的类型缩小范围，需要注意的是typeofnull 返回的是字符串object，ts在判断时会报错提示通过Boolean()可以返回一个type为boolean，value为true的类型通过!!world可以返回一个type为true，value为true的类型（一个狭窄的文字布尔类型 true） 平等缩小指的是通过===、!==、==、!=判断类型是否相同，，可以配合联合类型使用例如 123456789101112131415161718function example(x: string | number, y: string | boolean) { if (x === y) { // We can now call any 'string' method on 'x' or 'y'. x.toUpperCase(); (method) String.toUpperCase(): string y.toLowerCase(); (method) String.toLowerCase(): string } else { console.log(x); (parameter) x: string | number console.log(y); (parameter) y: string | boolean }} 通过in收窄通常搭配联合类型使用 123456789101112131415type Fish = { swim: () =&gt; void };type Bird = { fly: () =&gt; void };type Human = { swim?: () =&gt; void; fly?: () =&gt; void }; function move(animal: Fish | Bird | Human) { if (&quot;swim&quot; in animal) { animal; // (parameter) animal: Fish | Human } else { animal; // (parameter) animal: Bird | Human }} instanceof通过判断实例是否再原型上来收窄类型范围 1234567891011function logValue(x: Date | string) { if (x instanceof Date) { console.log(x.toUTCString()); // (parameter) x: Date } else { console.log(x.toUpperCase()); // (parameter) x: string }} Assignmentsts能根据右侧的赋值适当的收窄左侧 12345678let x = Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;; // let x: string | numberx = 1; console.log(x); // let x: number 这些分配中的每一个都是有效的，这是因为一开始x被赋值了number或string类型 控制语句基于可达性的代码分析称为控制流分析。TypeScript 在遇到类型保护和赋值时使用这种流分析来缩小类型。当分析一个变量时，控制流可以一次又一次地分裂和重新合并，并且可以观察到该变量在每个点具有不同的类型 使用类型谓词定义一个返回类型为类型谓词的函数谓词采用 形式 parameterName is Type 其中parameterName必须是当前函数签名中的参数名称感觉上像是自定义了一个用于收窄类型的函数返回值类型 举例说明 123456789101112function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined;}// Both calls to 'swim' and 'fly' are now okay.let pet = getSmallPet(); if (isFish(pet)) { pet.swim();} else { pet.fly();} Discriminated unions为了让ts能够更准确的检查，当我们通过一些属性去判断参数的类型时，编译器往往无法正确判断属性是否存在。虽然我们可以通过类型断言和非空声明解决，但应该有更好的办法。 我们需要将我们所知道的信息传达给类型检查器，可以更详细的声明类型 123456789101112131415161718192021222324interface Circle { kind: &quot;circle&quot;; radius: number;} interface Square { kind: &quot;square&quot;; sideLength: number;} type Shape = Circle | Square;function getArea(shape: Shape) { switch (shape.kind) { case &quot;circle&quot;: return Math.PI * shape.radius ** 2; // (parameter) shape: Circle case &quot;square&quot;: return shape.sideLength ** 2; // (parameter) shape: Square }} never 类型缩小范围时，可以将联合的选项减少到已消除所有可能性并且一无所有的程度。在这些情况下，TypeScript 将使用一种never类型来表示不应该存在的状态。 穷举检查never类型可以分配给任何类型，但是没有类型能够分配给never（never本身除外）。所以我们可以通过在switch语句中的default下通过赋值never来检查条件是否都考虑充分，ts会帮我们自动进行穷举检查 12345678910111213141516171819interface Triangle { kind: &quot;triangle&quot;; sideLength: number;} type Shape = Circle | Square | Triangle; function getArea(shape: Shape) { switch (shape.kind) { case &quot;circle&quot;: return Math.PI * shape.radius ** 2; case &quot;square&quot;: return shape.sideLength ** 2; default: const _exhaustiveCheck: never = shape;// Type 'Triangle' is not assignable to type 'never'. return _exhaustiveCheck; }}","link":"/2022/09/12/TypeScript%20%E6%94%B6%E7%AA%84/"},{"title":"JSX","text":"一种嵌入式的类似XML的语法。 它可以被转换成合法的JavaScript。常见的有React，博客所用到的库为inferno也是jsx。 JSX模式|模式| 输入| 输出| 输出文件扩展名||preserve| &lt;div /&gt;| &lt;div /&gt; |.jsx||react| &lt;div /&gt;| React.createElement(“div”)| .js||react-native| &lt;div /&gt;| &lt;div /&gt; |.js| as 操作符1var foo = &lt;foo&gt;bar; 上述代码将bar变量断言为foo类型。但是在jsx语法中解析会很困难。因此jsx禁用了尖括号的写法。ts通过提供 as 操作符来让jsx语法更好的实现断言。as操作符在ts和tsx文件都可以使用，与尖括号的行为是等价的 类型检查固有元素与基于值的元素之间的区别 为什么要区分固有元素与基于值的元素 对于React，固有元素会生成字符串（React.createElement(“div”)），然而由你自定义的组件却不会生成（React.createElement(MyComponent)） 传入JSX元素里的属性类型的查找方式不同 固有元素总是以一个小写字母开头，基于值的元素总是以一个大写字母开头 固有元素如果指定了接口JSX.IntrinsicElements，则通过接口查找，如果接口没有指定则全部通过，不对固有元素进行检查。 12345678declare namespace JSX { interface IntrinsicElements { foo: any }}&lt;foo /&gt;; // 正确&lt;bar /&gt;; // 错误 基于值的元素基于值的元素会简单的在它所在的作用域里按标识符查找 1234import MyComponent from &quot;./myComponent&quot;;&lt;MyComponent /&gt;; // 正确&lt;SomeOtherComponent /&gt;; // 错误 有两种方式可以定义基于值的元素： 函数组件 (FC) 类组件 由于这两种基于值的元素在JSX表达式里无法区分，因此TypeScript首先会尝试将表达式做为函数组件进行解析。如果解析成功，那么TypeScript就完成了表达式到其声明的解析操作。否则尝试以类组件进行解析，如果依旧失败，则抛出错误 函数组件TypeScript会强制函数组件的返回值可以赋值给JSX.Element，由于函数组件是简单的JavaScript函数，所以我们还可以利用函数重载。 12345678910111213141516interface ClickableProps { children: JSX.Element[] | JSX.Element}interface HomeProps extends ClickableProps { home: JSX.Element;}interface SideProps extends ClickableProps { side: JSX.Element | string;}function MainButton(prop: HomeProps): JSX.Element;function MainButton(prop: SideProps): JSX.Element { ...} 类组件 类组件的类型允许自定义。但是需要分清两个术语：元素类的类型 元素实例的类型 对于 class 来说，类类型是类的构造函数和静态部分。实例类型是class的实例的类型对于工厂函数来说，类类型为函数，实例类型为函数的返回值类型 元素的实例类型必须赋值给JSX.ElementClass或抛出一个错误。默认的JSX.ElementClass为{}，但可以被扩展用来限制JSX的类型以符合相应的接口 属性类型检查属性类型检查的第一步是确定_元素属性类型_。 这在固有元素和基于值的元素之间稍有不同 对于固有元素，是JSX.IntrinsicElements属性的类型 12345678declare namespace JSX { interface IntrinsicElements { foo: { bar?: boolean } }}// `foo`的元素属性类型为`{bar?: boolean}`&lt;foo bar /&gt;; 对于基于值的元素,取决于先前确定的在元素实例类型上的某个属性的类型。至于该使用哪个属性来确定类型取决于JSX.ElementAttributesProperty它应该使用单一的属性来定义。 这个属性名之后会被使用TypeScript 2.8，如果未指定JSX.ElementAttributesProperty，那么将使用类元素构造函数或函数组件调用的第一个参数的类型 12345678910111213141516declare namespace JSX { interface ElementAttributesProperty { props; // 指定用来使用的属性名 }}class MyComponent { // 在元素实例类型上指定属性 props: { foo?: string; }}// `MyComponent`的元素属性类型为`{foo?: string}`&lt;MyComponent foo=&quot;bar&quot; /&gt; 属性的检查支持支持可选属性和必须属性 JSX还会使用JSX.IntrinsicAttributes接口来指定额外的属性，这些额外的属性通常不会被组件的props或arguments使用，例如React里的key。 JSX.IntrinsicClassAttributes泛型类型也可以用来为类组件（非函数组件）指定相同种类的额外属性。泛型参数表示类实例类型。在React里，它用来允许Ref类型上的ref属性 子孙类型检查TypeScript 2.3 引入了children类型检查。利用JSX.ElementChildrenAttribute来决定children名。JSX.ElementChildrenAttribute应该被声明在单一的属性(property)里。 12345declare namespace JSX { interface ElementChildrenAttribute { children: {}; // specify children name to use }}","link":"/2022/10/29/Typescript%20JSX/"},{"title":"keyof 类型操作符","text":"简单来看就是获取key值的一个联合，如果是索引签名，则直接返回这些类型 数字字面量联合类型keyof 也可能返回一个数字字面量的联合类型 1234567891011121314151617const NumericObject = { [1]: &quot;冴羽一号&quot;, [2]: &quot;冴羽二号&quot;, [3]: &quot;冴羽三号&quot;};type result = keyof typeof NumericObject// typeof NumbericObject 的结果为：// {// 1: string;// 2: string;// 3: string;// }// 所以最终的结果为：// type result = 1 | 2 | 3 SymbolTypeScript 也可以支持 symbol 类型的属性名 1234567891011const sym1 = Symbol();const sym2 = Symbol();const sym3 = Symbol();const symbolToNumberMap = { [sym1]: 1, [sym2]: 2, [sym3]: 3,};type KS = keyof typeof symbolToNumberMap; // typeof sym1 | typeof sym2 | typeof sym3 所以有时候在使用字符串类型时会报错，因为无法指定symbol为string如果确定只使用字符串类型的属性名，可以这么写 123function useKey&lt;T, K extends Extract&lt;keyof T, string&gt;&gt;(o: T, k: K) { var name: string = k; // OK} 或者使用联合类型去处理 对于keyof的一些疑问当想要获取Map类型的key值组成的时候，该如何操作？ 1234const map1: Map&lt;object, string&gt; = new Map();const a = { key: &quot;object&quot; };type map = keyof typeof map1;// type map = keyof Map&lt;object, string&gt; 上述操作会产生问题，即无法拿到Map内key值的类型 搜索后发现ts没有对这块做处理，但是可以手动实现 123456type KeyOfMap&lt;M extends Map&lt;unknown, unknown&gt;&gt; = M extends Map&lt;infer K, unknown&gt; ? K : never;type map = KeyOfMap&lt;Map&lt;object, string&gt;&gt;;// type map = object 参考:ES Map 类型的 keyof 等价物什么","link":"/2022/10/26/Typescript%20keyof%20%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"title":"typeof 类型操作符","text":"js自带的 typeof 可以在表达式上下文中使用，而ts的 typeof 可以在类型上下文中使用。用于获取一个变量或者属性的类型。 限制只有对标识符（比如变量名）或者他们的属性使用 typeof 才是合法的","link":"/2022/10/26/Typescript%20typeof%20%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"title":"三斜线指令","text":"三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用 仅可放在包含它的文件的最顶端。一个三斜线指令前面只能出现单行或多行注释，包括其他的三斜线指令。否则被当为普通注释 /// &lt;reference path=&quot;...&quot; /&gt;用于声明文件间的依赖 当使用–out或–outFile时，它也可以做为调整输出内容顺序的一种方法。 文件在输出文件内容中的位置与经过预处理后的输入顺序一致 预处理输入文件编译器通过预处理解析所有三斜线指令，将额外的文件加到编译过程中。 过程从一些根文件开始，它们在命令行中指定的文件或是tsconfig.json中的files列表里的文件。这些根文件按指定的顺序预处理。在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。 三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析 一个三斜线引用路径是相对于包含它的文件的，如果不是根文件 错误引用不存在的文件会报错。 一个文件用三斜线指令引用自己会报错。 使用 –noResolve三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序 /// &lt;reference types=&quot;...&quot; /&gt;指令声明了对某个包的依赖。 对这些包的名字的解析与在import语句里对模块名的解析类似。 可以简单地把三斜线类型引用指令当做import声明的包 仅当在你需要写一个d.ts文件时才使用这个指令。 当且仅当 结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加/// &lt;reference types=&quot;...&quot; /&gt;语句 若要在.ts文件里声明一个对@types包的依赖，使用–types命令行选项或在tsconfig.json里指定 /// &lt;reference no-default-lib=&quot;true&quot;/&gt;把一个文件标记成 默认库。在lib.d.ts文件和它不同的变体的顶端看到这个注释 这个指令告诉编译器在编译过程中 不要 包含这个默认库（比如，lib.d.ts）。 这与在命令行上使用--noLib相似 当传递了--skipDefaultLibCheck时，编译器只会忽略检查带有/// &lt;reference no-default-lib=&quot;true&quot;/&gt;的文件 /// &lt;amd-module /&gt;指令允许给编译器传入一个可选的模块名 123///&lt;amd-module name='NamedModule'/&gt;export class C {} 这会将NamedModule传入到AMD define函数里","link":"/2022/10/31/Typescript%20%E4%B8%89%E6%96%9C%E7%BA%BF%E6%8C%87%E4%BB%A4/"},{"title":"声明合并","text":"可以在类型层面上描述JavaScript对象的模型 声明合并指指编译器将针对同一个名字的两个独立声明合并为单一声明。 合并后的声明同时拥有原先两个声明的特性。 任何数量的声明都可被合并；不局限于两个声明 基础概念TypeScript中的声明会创建以下三种实体之一：命名空间，类型或值 创建命名空间的声明会新建一个命名空间，它包含了用（.）符号来访问时使用的名字。 创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。 最后，创建值的声明会创建在JavaScript输出中看到的值。 Declaration Type Namespace Type Value Namespace X X Class X X Enum X X Interface X Type Alias X Function X Variable X 合并接口从根本上说，合并的机制是把双方的成员放到一个同名的接口里 12345678910interface Box { height: number; width: number;}interface Box { scale: number;}let box: Box = {height: 5, width: 6, scale: 10}; 接口的非函数的成员应该是唯一的，如果不唯一，则必须是相同的类型 对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。合并时后面的接口具有更高的优先级，即后来的接口重载会出现在考前的位置。有一个例外就是，如果签名里有一个参数的类型是_单一_的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端 1234567891011interface Document { createElement(tagName: any): Element;}interface Document { createElement(tagName: &quot;div&quot;): HTMLDivElement; createElement(tagName: &quot;span&quot;): HTMLSpanElement;}interface Document { createElement(tagName: string): HTMLElement; createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement;} 1234567interface Document { createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement; createElement(tagName: &quot;div&quot;): HTMLDivElement; createElement(tagName: &quot;span&quot;): HTMLSpanElement; createElement(tagName: string): HTMLElement; createElement(tagName: any): Element;} 合并命名空间同名的命名空间也会合并其成员，命名空间会创建出命名空间和值 对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口 对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里 合并之后，从其它命名空间合并进来的成员无法访问非导出成员 命名空间与类和函数和枚举类型合并合并命名空间和类123456class Album { label: Album.AlbumLabel;}namespace Album { export class AlbumLabel { }} 合并结果是一个类并带有一个内部类。需要将namespace中的类先导出。 命名空间与函数合并用于稍后对函数扩展，并保证类型安全 12345678910function buildLabel(name: string): string { return buildLabel.prefix + name + buildLabel.suffix;}namespace buildLabel { export let suffix = &quot;&quot;; export let prefix = &quot;Hello, &quot;;}console.log(buildLabel(&quot;Sam Smith&quot;)); 命名空间与枚举类合并12345678910111213141516171819202122enum Color { red = 1, green = 2, blue = 4}namespace Color { export function mixColor(colorName: string) { if (colorName == &quot;yellow&quot;) { return Color.red + Color.green; } else if (colorName == &quot;white&quot;) { return Color.red + Color.green + Color.blue; } else if (colorName == &quot;magenta&quot;) { return Color.red + Color.blue; } else if (colorName == &quot;cyan&quot;) { return Color.green + Color.blue; } }} 非法的合并类不能与其它类或变量合并，可以通过混入实现类似效果。 模块扩展指的就是 declare。当引入其他模块后对模块进行补丁式的扩展时，编译器无法识别我们对其进行的扩展，这是可以通过 declare 来告诉编译器。 12345678910111213141516171819202122// observable.tsexport class Observable&lt;T&gt; { // ... implementation left as an exercise for the reader ...}// map.tsimport { Observable } from &quot;./observable&quot;;declare module &quot;./observable&quot; { interface Observable&lt;T&gt; { map&lt;U&gt;(f: (x: T) =&gt; U): Observable&lt;U&gt;; }}Observable.prototype.map = function (f) { // ... another exercise for the reader}// consumer.tsimport { Observable } from &quot;./observable&quot;;import &quot;./map&quot;;let o: Observable&lt;number&gt;;o.map(x =&gt; x.toFixed()); 模块名的解析和用import/export解析模块标识符的方式是一致的 当这些声明在扩展中合并时，就如同在原始位置被声明一样。 但是，有两点限制需要注意 你不能在扩展中声明新的顶级声明－仅可以扩展模块中已经存在的声明 默认导出也不能扩展，只有命名的导出才可以（因为你需要使用导出的名字来进行扩展，并且default是保留关键字 全局扩展1234567891011121314// observable.tsexport class Observable&lt;T&gt; { // ... still no implementation ...}declare global { interface Array&lt;T&gt; { toObservable(): Observable&lt;T&gt;; }}Array.prototype.toObservable = function () { // ...} 全局扩展与模块扩展的行为和限制是相同的","link":"/2022/10/28/Typescript%20%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6/"},{"title":"映射类型","text":"一个类型需要基于另外一个类型，但是你又不想拷贝一份，这个时候可以考虑使用映射类型 映射类型建立在索引签名的语法上 123type OptionsFlags&lt;Type&gt; = { [Property in keyof Type]: boolean;}; 映射修饰符readonly 属性只读? 属性可选 通过前缀+-添加或删除修饰符，默认为+前缀 1234567891011121314151617181920// 删除属性中的只读属性type CreateMutable&lt;Type&gt; = { -readonly [Property in keyof Type]: Type[Property];};type LockedAccount = { readonly id: string; readonly name: string;}; type UnlockedAccount = CreateMutable&lt;LockedAccount&gt;;// type UnlockedAccount = {// id: string;// name: string;// }// 删除属性中的可选属性type Concrete&lt;Type&gt; = { [Property in keyof Type]-?: Type[Property];}; 通过 as 实现键名重新映射在映射类型中使用 as 语句实现键名重新映射 123type MappedTypeWithNewProperties&lt;Type&gt; = { [Properties in keyof Type as NewKeyType]: Type[Properties]} 可以利用模板字面量类型基于之前的属性名创建一个全新的属性名 12345678910111213type Getters&lt;Type&gt; = { [Property in keyof Type as `get${Capitalize&lt; string &amp; Property &gt;}`]: () =&gt; Type[Property];};interface Person { name: string; age: number; location: string;}type LazyPerson = Getters&lt;Person&gt;; 可以遍历任何联合类型 123456789101112type EventConfig&lt;Events extends { kind: string }&gt; = { [E in Events as E[&quot;kind&quot;]]: (event: E) =&gt; void;} type SquareEvent = { kind: &quot;square&quot;, x: number, y: number };type CircleEvent = { kind: &quot;circle&quot;, radius: number }; type Config = EventConfig&lt;SquareEvent | CircleEvent&gt;// type Config = {// square: (event: SquareEvent) =&gt; void;// circle: (event: CircleEvent) =&gt; void;// }","link":"/2022/10/27/Typescript%20%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"title":"条件类型","text":"用来帮助我们描述输入类型和输出类型之间的关系 1234567891011121314interface Animal { live(): void;}interface Dog extends Animal { woof(): void;} type Example1 = Dog extends Animal ? number : string; // type Example1 = number type Example2 = RegExp extends Animal ? number : string; // type Example2 = string 一般多搭配泛型使用 12345678910111213interface IdLabel { id: number /* some fields */;}interface NameLabel { name: string /* other fields */;} function createLabel(id: number): IdLabel;function createLabel(name: string): NameLabel;function createLabel(nameOrId: string | number): IdLabel | NameLabel;function createLabel(nameOrId: string | number): IdLabel | NameLabel { throw &quot;unimplemented&quot;;} 上面的例子使用了重载来控制输入与输出的关系，但过多的重载不是一件好事可以通过条件类型简化掉函数重载 1234567891011121314151617type NameOrId&lt;T extends number | string&gt; = T extends number ? IdLabel : NameLabel;function createLabel&lt;T extends number | string&gt;(idOrName: T): NameOrId&lt;T&gt; { throw &quot;unimplemented&quot;;} let a = createLabel(&quot;typescript&quot;);// let a: NameLabel let b = createLabel(2.8);// let b: IdLabel let c = createLabel(Math.random() ? &quot;hello&quot; : 42);// let c: NameLabel | IdLabel 条件类型约束123456789101112131415type MessageOf&lt;T&gt; = T extends { message: unknown } ? T[&quot;message&quot;] : never; interface Email { message: string;} interface Dog { bark(): void;} type EmailMessageContents = MessageOf&lt;Email&gt;; // type EmailMessageContents = string type DogMessageContents = MessageOf&lt;Dog&gt;; // type DogMessageContents = never 在条件类型里推断条件类型提供了 infer 关键词，可以从正在比较的类型中推断类型，然后在 true 分支里引用该推断结果。通过infer可以避免通过索引类型手动访问每一个变量类型 123type Flatten&lt;T&gt; = T extends any[] ? T[number] : T;type Flatten&lt;Type&gt; = Type extends Array&lt;infer Item&gt; ? Item : Type; 可以通过infer写一些类型帮助别名 123456789101112type GetReturnType&lt;Type&gt; = Type extends (...args: never[]) =&gt; infer Return ? Return : never; type Num = GetReturnType&lt;() =&gt; number&gt;;// type Num = number type Str = GetReturnType&lt;(x: string) =&gt; string&gt;;// type Str = string type Bools = GetReturnType&lt;(a: boolean, b: boolean) =&gt; boolean[]&gt;; // type Bools = boolean[] 当从多重调用签名（就比如重载函数）中推断类型的时候，会按照最后的签名进行推断，因为一般这个签名是用来处理所有情况的签名。 123456declare function stringOrNum(x: string): number;declare function stringOrNum(x: number): string;declare function stringOrNum(x: string | number): string | number; type T1 = ReturnType&lt;typeof stringOrNum&gt;; // type T1 = string | number 分发条件类型当在泛型中使用条件类型的时候，如果传入一个联合类型，就会变成 分发的 1234type ToArray&lt;Type&gt; = Type extends any ? Type[] : never; type StrArrOrNumArr = ToArray&lt;string | number&gt;; // type StrArrOrNumArr = string[] | number[] 如果你要避免这种行为，你可以用方括号包裹 extends 关键字的每一部分 123456type ToArrayNonDist&lt;Type&gt; = [Type] extends [any] ? Type[] : never; // 'StrArrOrNumArr' is no longer a union.type StrArrOrNumArr = ToArrayNonDist&lt;string | number&gt;;// type StrArrOrNumArr = (string | number)[]","link":"/2022/10/27/Typescript%20%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B/"},{"title":"枚举类型","text":"枚举可以清晰地表达意图或创建一组有区别的用例。TypeScript支持数字的和基于字符串的枚举 数字枚举123456enum Direction { Up = 1, Down, Left, Right} Up下方的成员从1开始依次增加。如果未声明Up为1，则默认为0。 使用枚举 通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型 12345678910enum Response { No = 0, Yes = 1,}function respond(recipient: string, message: Response): void { // ...}respond(&quot;Princess Caroline&quot;, Response.Yes) 数字枚举可以被混入到计算过的和常量成员。 简短地说，没有初始化器的成员要么在首位，要么必须在用数值常量或其他常量枚举成员初始化的数值枚举之后 1234enum E { A = getSomeValue(), B, // Error! Enum member must have initializer.} 字符串枚举每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化，即可读性更强。 可以通过反向映射加强数字枚举的可读性 异构枚举从技术的角度来说，枚举可以混合字符串和数字成员 除非你真的想要利用JavaScript运行时的行为，否则不建议这样做 计算的结果和常量成员枚举成员的值可以是常量或计算出来的。 当满足如下条件时，枚举成员被当作是常量： 是枚举的第一个成员且没有初始化器，此时被赋值为0 不带有初始化器且它之前的枚举成员是一个 数字 常量 枚举成员使用 常量枚举表达式 初始化 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式 一个枚举表达式字面量 一个对之前定义的常量枚举成员的引用 带括号的常量枚举表达式 一元运算符+, -, ~其中之一应用在了常量枚举表达式 常量枚举表达式做为二元运算符+, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象 若常量枚举表达式求值后为NaN或Infinity，则会在编译阶段报错 所有其它情况的枚举成员被当作是需要计算得出的值 联合枚举与枚举成员的类型存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为 任何字符串字面量（例如：”foo”，”bar”，”baz”） 任何数字字面量（例如：1, 100） 应用了一元-符号的数字字面量（例如：-1, -100） 当所有枚举成员都拥有字面量枚举值时,枚举成员成为了类型 我们可以说某些成员 只能 是枚举成员的值 12345678910111213141516171819enum ShapeKind { Circle, Square,}interface Circle { kind: ShapeKind.Circle; radius: number;}interface Square { kind: ShapeKind.Square; sideLength: number;}let c: Circle = { kind: ShapeKind.Square, // Error! Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'. radius: 100,} 另一个变化是枚举类型本身变成了每个枚举成员的 联合通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合，从而捕获在比较值时犯得错误 1234567891011enum E { Foo, Bar,}function f(x: E) { if (x !== E.Foo || x !== E.Bar) { // ~~~~~~~~~~~ // Error! This condition will always return 'true' since the types 'E.Foo' and 'E.Bar' have no overlap. }} 运行时的枚举枚举是在运行时真正存在的对象 1234567891011enum E { X, Y, Z}function f(obj: { X: number }) { return obj.X;}// 没问题，因为 'E'包含一个数值型属性'X'。f(E); 编译时的枚举尽管一个枚举是在运行时真正存在的对象，但keyof关键字的行为与其作用在对象上时有所不同 应该使用keyof typeof来获取一个表示枚举里所有字符串key的类型 123456789enum LogLevel { ERROR, WARN, INFO, DEBUG}/** * 等同于： * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG'; */type LogLevelStrings = keyof typeof LogLevel; 对于数字枚举在编译时会自动添加反向映射","link":"/2022/10/29/Typescript%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"},{"title":"模板字面量类型","text":"与js语法相同，但只能在类型操作中使用。多用于基于一个类型内部的信息定义一个新的字符串 当模板中的变量是一个联合类型时，每一个可能的字符串字面量都会被表示 如果模板字面量里的多个变量都是联合类型，结果会交叉相乘 1234567891011type EmailLocaleIDs = &quot;welcome_email&quot; | &quot;email_heading&quot;;type FooterLocaleIDs = &quot;footer_title&quot; | &quot;footer_sendoff&quot;; type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;// type AllLocaleIDs = &quot;welcome_email_id&quot; | &quot;email_heading_id&quot; | &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;type Lang = &quot;en&quot; | &quot;ja&quot; | &quot;pt&quot;; type LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;// type LocaleMessageIDs = &quot;en_welcome_email_id&quot; | &quot;en_email_heading_id&quot; | &quot;en_footer_title_id&quot; | &quot;en_footer_sendoff_id&quot; | &quot;ja_welcome_email_id&quot; | &quot;ja_email_heading_id&quot; | &quot;ja_footer_title_id&quot; | &quot;ja_footer_sendoff_id&quot; | &quot;pt_welcome_email_id&quot; | &quot;pt_email_heading_id&quot; | &quot;pt_footer_title_id&quot; | &quot;pt_footer_sendoff_id&quot; 类型中的字符串联合类型12345678type PropEventSource&lt;Type&gt; = { on(eventName: `${string &amp; keyof Type}Changed`, callback: (newValue: any) =&gt; void): void;}; /// Create a &quot;watched object&quot; with an 'on' method/// so that you can watch for changes to properties.declare function makeWatchedObject&lt;Type&gt;(obj: Type): Type &amp; PropEventSource&lt;Type&gt;; string &amp; keyof Type 不能写成 keyof Type，会报错。因为keyof返回的是 string|number|symbol 类型，而模板字面量要求的类型是 string | number | bigint | boolean | null | undefined 多了一个symbol类型。可以通过Exclude或Extract去除symbol或提取string避免上述错误 内置字符操作类型 Uppercase把每个字符转为大写形式 Lowercase把每个字符转为小写形式 Capitalize把字符串的第一个字符转为大写形式 Uncapitalize把字符串的第一个字符转换为小写形式","link":"/2022/10/27/Typescript%20%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"title":"Typescript 泛型","text":"在比如 C# 和 Java 语言中，用来创建可复用组件的工具，我们称之为泛型（generics）。利用泛型，可以创建支持多类型的组件，从而减少不必要的工作。 使用泛型类型变量编译器会强制你在函数体内，正确的使用这些类型参数。假如我们在泛型参数中传入了number，则无法在函数体内调用该参数的length属性。 12345function loggingIdentity&lt;Type&gt;(arg: Type): Type { console.log(arg.length); // Property 'length' does not exist on type 'Type'. return arg;} 可以通过更改实参arg的参数类型来规避该情况： 1234function loggingIdentity&lt;Type&gt;(arg: Type[]): Type[] { console.log(arg.length); return arg;} 泛型类型改写的函数 123function identity&lt;Type&gt;(arg: Type): Type { return arg;} 泛型函数1let myIdentity: &lt;Type&gt;(arg: Type) =&gt; Type = identity; 泛型类型参数（Type）可以使用不同名字，只要数量和使用方式一致即可 也可以以对象类型的调用签名的形式，书写这个泛型类型 1let myIdentity: { &lt;Type&gt;(arg: Type): Type } = identity; 泛型接口 123456789interface GenericIdentityFn { &lt;Type&gt;(arg: Type): Type;}function identity&lt;Type&gt;(arg: Type): Type { return arg;} let myIdentity: GenericIdentityFn = identity; 有的时候，我们会希望将泛型参数作为整个接口的参数，这可以让我们清楚的知道传入的是什么参数 123456789interface GenericIdentityFn&lt;Type&gt; { (arg: Type): Type;} function identity&lt;Type&gt;(arg: Type): Type { return arg;} let myIdentity: GenericIdentityFn&lt;number&gt; = identity; 当要描述一个包含泛型的类型时，理解什么时候把类型参数放在调用签名里，什么时候把它放在接口里是很有用的。 个人理解，当参数类型或返回值类型确定时，可以使用第二种去约束。类似于一种把类型校验提高了一级这种感觉。 泛型类写法上类似于泛型接口 12345678910class GenericNumber&lt;NumType&gt; { zeroValue: NumType; add: (x: NumType, y: NumType) =&gt; NumType;}let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) { return x + y;}; 一个类它的类型有两部分：静态部分和实例部分。泛型类仅仅对实例部分生效，所以当我们使用类的时候，注意静态成员并不能使用类型参数 类中的constructor就是静态类型。可以通过一个create函数先去实现接口从而规范静态类型，通过这个create函数去new class进而实现实例部分的规范。 泛型约束通过让泛型参数继承接口达到约束的效果 12345678interface Lengthwise { length: number;} function loggingIdentity&lt;Type extends Lengthwise&gt;(arg: Type): Type { console.log(arg.length); // Now we know it has a .length property, so no more error return arg;} 在泛型约束中使用类型参数可以声明一个类型参数，这个类型参数被其他类型参数约束 举个例子，我们希望获取一个对象给定属性名的值，为此，我们需要确保我们不会获取 obj 上不存在的属性。所以我们在两个类型之间建立一个约束 1234567891011function getProperty&lt;Type, Key extends keyof Type&gt;(obj: Type, key: Key) { return obj[key];} let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, &quot;a&quot;);getProperty(x, &quot;m&quot;);// Argument of type '&quot;m&quot;' is not assignable to parameter of type '&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;'. 在泛型中使用类类型123function create&lt;Type&gt;(c: { new (): Type }): Type { return new c();} 和之前说的规避class的问题类似，创建了一个create函数","link":"/2022/10/26/Typescript%20%E6%B3%9B%E5%9E%8B/"},{"title":"类","text":"关于Class的学习 字段strictPropertyInitialization选项控制了类字段是否需要在构造函数里初始化 注意，字段需要在构造函数自身进行初始化。TypeScript 并不会分析构造函数里你调用的方法，进而判断初始化的值，因为一个派生类也许会覆盖这些方法并且初始化成员失败 如果不希望通过constructor初始化，可以加上非空断言 1234class OKGreeter { // Not initialized, but no error name!: string;} readonly通过前缀readonly阻止在构造函数外赋值 构造函数可以使用带类型注解的参数、默认值、重载等但类构造函数签名与函数签名之间也有一些区别 构造函数不能有类型参数 构造函数不能有返回类型注解，因为总是返回类实例类型 Super 调用ts会在需要的时候提醒调用super() 方法方法跟函数、构造函数一样，使用相同的类型注解.TypeScript 并没有给方法添加任何新的东西 注意在一个方法体内，它依然可以通过 this. 访问字段和其他的方法。方法体内一个未限定的名称（unqualified name，没有明确限定作用域的名称）总是指向闭包作用域里的内容 Getters / SetterTypeScript 对存取器有一些特殊的推断规则 如果 get 存在而 set 不存在，属性会被自动设置为 readonly 如果 setter 参数的类型没有指定，它会被推断为 getter 的返回类型 getters 和 setters 必须有相同的成员可见性（Member Visibility。 从 TypeScript 4.3 起，存取器在读取和设置的时候可以使用不同的类型 索引签名类可以声明索引签名，它和对象类型的索引签名是一样的 类继承implements通过 implements 语句检查是否满足接口类也可以实现多个接口，比如 class C implements A, B { implements 语句仅仅检查类是否按照接口类型实现，但它并不会改变类的类型或者方法的类型 extend类可以 extend 一个基类。一个派生类有基类所有的属性和方法，还可以定义额外的成员 一个派生类可以覆写一个基类的字段或属性。你可以使用 super 语法访问基类的方法 TypeScript 强制要求派生类总是它的基类的子类型 初始化顺序 类初始化的顺序，就像在 JavaScript 中定义的那样： 基类字段初始化 基类构造函数运行 派生类字段初始化 派生类构造函数运行 成员可见性public默认的可见性为 public，一个 public 的成员可以在任何地方被获取 protectedprotected 成员仅仅对子类可见 暴露受保护成员 123456789class Base { protected m = 10;}class Derived extends Base { // No modifier, so default is 'public' m = 15;}const d = new Derived();console.log(d.m); // OK 交叉等级受保护成员访问 不同的 OOP 语言在通过一个基类引用是否可以合法的获取一个 protected 成员是有争议的 123456789101112131415class Base { protected x: number = 1;}class Derived1 extends Base { protected x: number = 5;}class Derived2 extends Base { f1(other: Derived2) { other.x = 10; } f2(other: Base) { other.x = 10; // Property 'x' is protected and only accessible through an instance of class 'Derived2'. This is an instance of class 'Base'. }} java合法，ts不合法，C#和C++也如此 private 类似 protected ,但是不允许访问成员，即便是子类 交叉实例私有成员访问TypeScript 允许交叉实例私有成员的获取： 12345678class A { private x = 10; public sameAs(other: A) { // No error return other.x === this.x; }} 警告private和 protected 仅仅在类型检查的时候才会强制生效.意味着在 JavaScript 运行时，像 in 或者简单的属性查找，依然可以获取 private 或者 protected 成员. private 允许在类型检查的时候，通过方括号语法进行访问。这让比如单元测试的时候，会更容易访问 private 字段，这也让这些字段是弱私有（soft private）而不是严格的强制私有 静态成员类可以有静态成员，静态成员跟类实例没有关系，可以通过类本身访问到 同样可以使用 public protected 和 private 这些可见性修饰符 静态成员也可以被继承 特殊静态名称类本身是函数，而覆写 Function 原型上的属性通常认为是不安全的，因此不能使用一些固定的静态名称，函数属性像 name、length、call 不能被用来定义 static 成员 为什么没有静态类静态类之所以存在是因为语言将数据限制在类里。但ts中不存在，所以没有必要。一个对象或者单独的类就能完成 类静态块允许你写一系列有自己作用域的语句，也可以获取类里的私有字段 意味着我们可以安心的写初始化代码：正常书写语句，无变量泄漏，还可以完全获取类中的属性和方法 12345678910111213141516class Foo { static #count = 0; get count() { return Foo.#count; } static { try { const lastInstances = loadLastInstances(); Foo.#count += lastInstances.length; } catch {} }} 泛型类累得类型参数的推断和函数调用时同样的方式 类跟接口一样也可以使用泛型约束以及默认值 12345678910class Box&lt;Type&gt; { contents: Type; constructor(value: Type) { this.contents = value; }} const b = new Box(&quot;hello!&quot;);// const b: Box&lt;string&gt; 静态成员中的类型参数 12345class Box&lt;Type&gt; { static defaultValue: Type; // Static members cannot reference class type parameters.} 类型会被完全抹除，运行时，只有一个 Box.defaultValue 属性槽。这也意味着如果设置 Box&lt;string&gt;.defaultValue 是可以的话，这也会改变 Box&lt;number&gt;.defaultValue 类运行时的 thists提供了一些方式去减缓或阻止js本身this指向比较混乱的问题 箭头函数如果你有一个函数，经常在被调用的时候丢失 this 上下文，使用一个箭头函数或许更好些 1234567891011class MyClass { name = &quot;MyClass&quot;; getName = () =&gt; { return this.name; };}const c = new MyClass();const g = c.getName;// Prints &quot;MyClass&quot; instead of crashingconsole.log(g()); this 的值在运行时是正确的，即使 TypeScript 不检查代码 这会使用更多的内存，因为每一个类实例都会拷贝一遍这个函数。 你不能在派生类使用 super.getName ，因为在原型链中并没有入口可以获取基类方法。 this 参数在 TypeScript 方法或者函数的定义中，第一个参数且名字为 this 有特殊的含义。该参数会在编译的时候被抹除 12345// TypeScript input with 'this' parameterfunction fn(this: SomeType, x: number) { /* ... */} 1234// JavaScript outputfunction fn(x) { /* ... */} JavaScript 调用者依然可能在没有意识到它的时候错误使用类方法 每个类一个函数，而不是每一个类实例一个函数 基类方法定义依然可以通过 super 调用 this 类型在类中，有一个特殊的名为 this 的类型，会动态的引用当前类的类型 12345678class Box { contents: string = &quot;&quot;; set(value: string) { // (method) Box.set(value: string): this this.contents = value; return this; }} 这里，TypeScript 推断 set 的返回类型为 this 而不是 Box 也可以在参数类型注解中使用 this 123456class Box { content: string = &quot;&quot;; sameAs(other: this) { return other.content === this.content; }} 如果你有一个派生类，它的 sameAs 方法只接受来自同一个派生类的实例 123456789101112131415161718class Box { content: string = &quot;&quot;; sameAs(other: this) { return other.content === this.content; }} class DerivedBox extends Box { otherContent: string = &quot;?&quot;;} const base = new Box();const derived = new DerivedBox();derived.sameAs(base);// Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'. // Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'. 基于 this 的类型保护可以在类和接口的方法返回的位置，使用 this is Type 。当搭配使用类型收窄 (举个例子，if 语句)，目标对象的类型会被收窄为更具体的 Type 12345678910111213141516171819class Box&lt;T&gt; { value?: T; hasValue(): this is { value: T } { return this.value !== undefined; }} const box = new Box();box.value = &quot;Gameboy&quot;; box.value; // (property) Box&lt;unknown&gt;.value?: unknown if (box.hasValue()) { box.value; // (property) value: unknown} 参数属性TypeScript 提供了特殊的语法，可以把一个构造函数参数转成一个同名同值的类属性。这些就被称为参数属性.可以通过在构造函数参数前添加一个可见性修饰符 public private protected 或者 readonly 来创建参数属性,最后这些类属性字段也会得到这些修饰符 123456789101112131415class Params { constructor( public readonly x: number, protected y: number, private z: number ) { // No body necessary }}const a = new Params(1, 2, 3);console.log(a.x);// (property) Params.x: numberconsole.log(a.z);// Property 'z' is private and only accessible within class 'Params'. 类表达式类表达式跟类声明非常类似，唯一不同的是类表达式不需要一个名字，尽管我们可以通过绑定的标识符进行引用 123456789const someClass = class&lt;Type&gt; { content: Type; constructor(value: Type) { this.content = value; }}; const m = new someClass(&quot;Hello, world&quot;); // const m: someClass&lt;string&gt; 抽象类和成员TypeScript 中，类、方法、字段都可以是抽象的 抽象方法或者抽象字段是不提供实现的。这些成员必须存在在一个抽象类中，这个抽象类也不能直接被实例化 抽象类的作用是作为子类的基类，让子类实现所有的抽象成员。当一个类没有任何抽象成员，他就会被认为是具体的（concrete） 抽象构造签名有的时候，你希望接受传入可以继承一些抽象类产生一个类的实例的类构造函数 12345678910111213abstract class Base { abstract getName(): string; printName() { console.log(&quot;Hello, &quot; + this.getName()); }}function greet(ctor: typeof Base) { const instance = new ctor(); // Cannot create an instance of an abstract class. instance.printName();} 但如果你写一个函数接受传入一个构造签名 12345678910function greet(ctor: new () =&gt; Base) { const instance = new ctor(); instance.printName();}greet(Derived);greet(Base);// Argument of type 'typeof Base' is not assignable to parameter of type 'new () =&gt; Base'.// Cannot assign an abstract constructor type to a non-abstract constructor type. 现在 TypeScript 会正确的告诉你，哪一个类构造函数可以被调用，Derived 可以，因为它是具体的，而 Base 是不能的。","link":"/2022/10/27/Typescript%20%E7%B1%BB/"},{"title":"类型兼容","text":"TypeScript里的类型兼容性是基于结构类型系统的，只要二者的结构组成相同，就认为二者属于统一类型 123456789interface Pet { name: string;}class Dog { name: string;}let pet: Pet;// OK, because of structural typingpet = new Dog(); 关于可靠性的注意事项TypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的 TypeScript结构类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的成员。可以有额外的属性存在。 比较两个函数首先看它们的参数列表，要求类型相同 函数参数双向协变/函数协逆变协变 当子类型包含父类型的属性时，允许子类型的变量赋值给父类型的变量，称为协变 逆变 参数为父类型的函数可以被赋值给参数为子类型的函数，称为逆变。假如颠倒过来，就变成了类型不安全的情况。因为父类型的约束更少，范围更广，子类型的约束更多。子类型中的属性可能父类型中并没有要求 在ts2.x前支持父类型可以赋给子类型，子类型同样可以赋给父类型，称为双向协变。但因为双向协变的不安全性，ts之后加入了 strictFunctionTypes，设置为true即可关闭双向协变的支持 默认情况下，一个函数类型中返回值类型是协变的，而参数类型是逆变的 TypeScript 中的子类型、逆变、协变是什么 可选参数及剩余参数比较函数兼容性的时候，可选参数与必须参数是可互换的，即二者在类型判断上没有区别，剩余参数则是被当做无限个可选参数 从运行时角度来看，可选参数一般不强制，因为对于大部分函数来说相当于传递了一些undefinded。 函数重载对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名 枚举枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的 12345enum Status { Ready, Waiting };enum Color { Red, Blue, Green };let status = Status.Ready;status = Color.Green; // Error 类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内 123456789101112class Animal { feet: number; constructor(name: string, numFeet: number) {}}class Size { feet: number; constructor(numFeet: number) {}}let a: Animal;let s: Size;a = s; // OKs = a; // OK 类的私有成员和受保护成员当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员 这条规则也适用于包含受保护成员实例的类型检查。允许子类赋值给父类，但是不能赋值给其它有同样类型的类 泛型类型参数只影响使用其做为类型一部分的结果类型 1234interface Empty&lt;T&gt; {}let x: Empty&lt;number&gt;;let y: Empty&lt;string&gt;;x = y; // OK, 因为y和x的结构相匹配 当结果类型使用了类型参数时，比较会发生变化 123456interface NotEmpty&lt;T&gt; { data: T;}let x: NotEmpty&lt;number&gt;;let y: NotEmpty&lt;string&gt;;x = y; // Error, 因为x和y不兼容","link":"/2022/10/31/Typescript%20%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9/"},{"title":"索引访问类型","text":"通过索引访问类型可以查找另外一个类型上的特定属性 可以使用联合、keyof 或者其他类型 1234567891011type Person = { age: number; name: string; alive: boolean };type I1 = Person[&quot;age&quot; | &quot;name&quot;]; // type I1 = string | number type I2 = Person[keyof Person];// type I2 = string | number | boolean type AliveOrName = &quot;alive&quot; | &quot;name&quot;;type I3 = Person[AliveOrName]; // type I3 = string | boolean 作为索引的只能是类型不能使用 const 创建一个变量引用 123456const key = &quot;age&quot;;type Age = Person[key];// Type 'key' cannot be used as an index type.// 'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'? 可以使用类型别名实现类似的重构 123type key = &quot;age&quot;;type Age = Person[key];","link":"/2022/10/27/Typescript%20%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B/"},{"title":"generator与async&#x2F;await","text":"之前就一直在困惑，await 后面包的那一大群代码到底是怎么个处理，闲下来了，这就学习一波 async和await是generator和Promise的语法糖，本质上是是将 Generator 函数和自动执行器，包装在一个函数里。 123456789async function fn(args) { // ...}// 等同于function fn(args) { return spawn(function* () { // ... });} spawn函数的实现，是Thunk函数的一种体现 12345678910111213141516171819202122function spawn(genF){ return new Promise(function(trdolve, reject){ const gen = genF(); function step(nextF){ let next; try{ next = nextF(); }catch(e){ return reject(e); }; if(next.done){ return resolve(next.value); }; Promise.resolve(next.value).then(function(v){ step(function(){ return gen.next(v); }); },function(e){ step(function(){ return gen.throw(e); }); }); } step(function(){ return gen.next(undefined); }); })} Thunk函数1234567891011121314let x = 1;function f(m){ return m*2;}f(x+5)// 等同于let thunk = function(){ return x+5;}function f(thunk){ return thunk() * 2;} 编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数 Thunk函数的一大亮点就是其自动流程管理，也是Generator函数自动执行器的实现原理。 通过thunk函数，我们能够自动化交付控制权 12345678910111213141516function run(fn){ let gen = fn(); function next(err, data){ let result = gen.next(data); if(result.done) return; result.value(next); } next();}function* g(){ // ...};run(g); 我们都知道generator函数本身的执行需要通过next方法配合yield操作指针来放行任务，将控制权交接。但async和await并未出现相关的操作，只需要我们声明async函数和await的代码即可，函数会按顺序依次执行。 这本质上是通过thunk函数的自动执行的特点和Promise的状态实现的。通过thunk函数，我们可以不用手动调用next，而是通过判断上一次next的执行结果是否结束(done是否为true)来继续执行或跳出 在Promise的Pending状态发生改变后，如果是 resolve，则通过Promise的then方法，生成一个新的Peomise对象，链式、递归的去执行下一个next方法，然后等待下一个Promise的状态改变，继续执行next，直到发现done为true为止。","link":"/2022/10/31/generator%E4%B8%8Easync%E3%80%81await/"},{"title":"hbuilder 启动微信开发者工具失败问题汇总","text":"费劲呐，之前电脑坏过一次，再加上多少时间没用过 hbuilder 了…，出了点问题，启动微信开发者工具总是不行，记录下解决的方法 > 检查步骤微信开发者工具安装位置打开hbuilder中的Settings.json 运行=&gt;运行到小程序模拟器=&gt;运行设置 找到 微信开发者工具路径，检查配置是否有误 检查微信开发者工具端口号配置打开微信开发者工具，在安全选项里开启服务端口 重点检查是否配置 appId如果上面的两步都没有问题，那么应该就是appid的问题了。首先要搞清楚的是 DCloud的AppId和微信开发者工具的AppId是不一样的。微信开发者工具的AppId在manifest.json内微信小程序里面 微信开发者工具的appId需要在微信公众平台获取。 如果使用游客登录微信开发者工具，而在hbuilder的 manifest.json=&gt;微信小程序 写了appId的话，是无法正常打开微信开发者工具的。 12345678910:26:33.467 正在启动微信开发者工具...10:26:35.496 [微信小程序开发者工具] [error] Error: Fail to open IDE10:26:35.496 [微信小程序开发者工具]10:26:35.499 [微信小程序开发者工具] - initialize10:26:35.500 [微信小程序开发者工具]10:26:35.502 [微信小程序开发者工具] √ IDE server has started, listening on http://127.0.0.1:2500710:26:35.503 [微信小程序开发者工具] - open IDE10:26:35.506 [微信小程序开发者工具]10:26:35.506 [微信小程序开发者工具] × open IDE 针对上面的问题，有两种方法解决 一个是在微信开发者平台上申请appId并更改项目中的appId 删除项目中微信小程序的appId，这样就能够在hbuilder中启动游客身份的微信开发者工具","link":"/2022/10/31/hbuilder%E5%90%AF%E5%8A%A8%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"},{"title":"从开源框架el-admin中学习状态模式","text":"最近在写项目时，想起之前看到开源框架eladmin里面表单有一个特性，就是全局只有一份代码，一个表单组件（类似表单的外框把，只有title和button等，输入控件不在其内），但是有很多不同的展示效果，例如新建，编辑，提交中等。不管哪个模块都共用的是同一个表单。这样无疑有助于后期的维护，了解后发现是用到了状态模式。这次简单记录下eladmin是如何使用状态模式的，因为本次项目也涉及到了类似的场景，看看能不能用上。 状态模式的定义与特点状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。 State抽象状态角色 接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。 ConcreteState具体状态角色 具体状态主要有两个职责:一是处理本状态下的事情，二是从本状态如何过渡到其他状态。 Context环境角色 定义客户端需要的接口，并且负责具体状态的切换。 eladmin框架混入及封装用的比较多，导致我也不能很具体的判断出来具体的角色指的是谁，如果有知道的还请留言告诉我，谢谢。 在eladmin中，框架对数据的新增和表单的编辑、删除都通过状态模式去处理了部分逻辑判断。框架并不是针对某个具体的组件进行的状态处理，而是针对的整个过程进行的状态处理。不同组件通过该过程的不同状态，也会有不同的表现形式，例如按钮的loading显示、表单的标题与显示、方法处理的逻辑等。 下面主要以新增数据为例，具体介绍下eladmin中状态模式的实现。 数据新增在eladmin中的状态定义 123456789// src/compents/Crud/crud.js/** * CRUD状态 */CRUD.STATUS = { NORMAL: 0, PREPARED: 1, PROCESSING: 2} 关键组件 1234567891011121314151617181920212223// src/compents/Crud/CRUD.operation.vue&lt;template&gt; ... &lt;el-button v-if=&quot;crud.optShow.add&quot; v-permission=&quot;permission.add&quot; class=&quot;filter-item&quot; size=&quot;mini&quot; type=&quot;primary&quot; icon=&quot;el-icon-plus&quot; @click=&quot;crud.toAdd&quot; &gt; 新增 &lt;/el-button&gt; ...&lt;/template&gt;&lt;script&gt;// 该处通过混入的方式将crud的方法引进来import CRUD, { crud } from '@/compents/Crud//crud.js'export default { mixins: [crud()],}&lt;/script&gt; 这里主要混入的是一些逻辑处理的方法、CRUD状态定义和一些关键的data数据混入后的关键属性有下面这些 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// src/compents/Crud/CRUD.operation.vue&lt;template&gt; ... &lt;el-button v-if=&quot;crud.optShow.add&quot; v-permission=&quot;permission.add&quot; class=&quot;filter-item&quot; size=&quot;mini&quot; type=&quot;primary&quot; icon=&quot;el-icon-plus&quot; @click=&quot;crud.toAdd&quot; &gt; 新增 &lt;/el-button&gt; ...&lt;/template&gt;&lt;script&gt;export default { data() { return { // 通过混入进来的 // ... 省略多余的属性 status: { add: CRUD.STATUS.NORMAL, edit: CRUD.STATUS.NORMAL, // 添加或编辑状态 // 表单、按钮loading等组件的状态都是根据这里判断的 get cu() { if (this.add === CRUD.STATUS.NORMAL &amp;&amp; this.edit === CRUD.STATUS.NORMAL) { return CRUD.STATUS.NORMAL } else if (this.add === CRUD.STATUS.PREPARED || this.edit === CRUD.STATUS.PREPARED) { return CRUD.STATUS.PREPARED } else if (this.add === CRUD.STATUS.PROCESSING || this.edit === CRUD.STATUS.PROCESSING) { return CRUD.STATUS.PROCESSING } throw new Error('wrong crud\\'s cu status') }, // 标题，控制表单Dialog组件标题在不同状态下的显示 get title() { return this.add &gt; CRUD.STATUS.NORMAL ? `新增${crud.title}` : this.edit &gt; CRUD.STATUS.NORMAL ? `编辑${crud.title}` : crud.title } } } }, methods:{ // ... 省略多余的方法 /** * 启动添加 */ toAdd() { // 重置表单数据 crud.resetForm() // 对自定义钩子进行处理，如果设置了就执行 if (!(callVmHook(crud, CRUD.HOOK.beforeToAdd, crud.form) &amp;&amp; callVmHook(crud, CRUD.HOOK.beforeToCU, crud.form))) { return } // 更改add的状态，从NORMAL变为PREPARED crud.status.add = CRUD.STATUS.PREPARED // 此时会弹出来el-dialog。该弹框通过:visible.sync=&quot;crud.status.cu &gt; 0&quot;控制显示 // 对自定义钩子进行处理，如果设置了就执行 callVmHook(crud, CRUD.HOOK.afterToAdd, crud.form) callVmHook(crud, CRUD.HOOK.afterToCU, crud.form) }, /** * 提交新增/编辑 */ submitCU() { if (!callVmHook(crud, CRUD.HOOK.beforeValidateCU)) { return } // 找到当前根据status显示的form组件，并进行校验 crud.findVM('form').$refs['form'].validate(valid =&gt; { if (!valid) { return } // 是否执行钩子 if (!callVmHook(crud, CRUD.HOOK.afterValidateCU)) { return } // 根据状态去判断具体的执行方法 if (crud.status.add === CRUD.STATUS.PREPARED) { crud.doAdd() } else if (crud.status.edit === CRUD.STATUS.PREPARED) { crud.doEdit() } }) }, /** * 执行添加 */ doAdd() { // 自定义钩子 if (!callVmHook(crud, CRUD.HOOK.beforeSubmit)) { return } // 更改整个添加过程的状态为PROCESSING crud.status.add = CRUD.STATUS.PROCESSING // 调取添加接口(此处eladmin做了一定处理，通过crudMethod和其属性即可调取自己定义的接口地址) crud.crudMethod.add(crud.form).then(() =&gt; { // 成功后将状态更改为初始状态 = 关闭表单，停止loading crud.status.add = CRUD.STATUS.NORMAL crud.resetForm() crud.addSuccessNotify() callVmHook(crud, CRUD.HOOK.afterSubmit) crud.toQuery() }).catch(() =&gt; { // 出错后就更改为PREPARED状态(新增的第二个状态，此时表单仍然存在) crud.status.add = CRUD.STATUS.PREPARED callVmHook(crud, CRUD.HOOK.afterAddError) }) }, }}&lt;/script&gt; 简单来说，eladmin通过状态模式针对整个添加的流程做了如下规定： NORMAL阶段 表单控件不显示 按钮loading为false 点击新增，进入PREPARED阶段 表单显示，获取该阶段表单对应的标题 点击确定，进入PROCESSING阶段 显示loading 发出请求 如果成功，重新设置为NORMAL阶段 如果失败，则回到PREPARED阶段 总结整个过程涉及到的组件有很多，只不过表单和按钮是最显眼的，并且按钮有很多个。框架通过状态模式将很多按钮的判断逻辑抽离了出来，减少了不少工作量。通过状态的判断去控制了各个组件自己的表现形式，在后期维护时也更加容易。 后面有人接手的话也只需要关注关键方法的逻辑。而不是散落在各个组件中的小按钮和表单样式的逻辑了(假如不使用该模式)。","link":"/2022/10/31/%E4%BB%8E%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6el-admin%E4%B8%AD%E5%AD%A6%E4%B9%A0%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"title":"关于国际化","text":"针对导航栏添加了一部分国际化的内容，针对后期可能添加的需要国际化的模块做一份记录 选择指定语言在 icarus 中，语言默认是英语，在&lt;root&gt;/_config.yml中的 language 选项中可以看到 当前为 en。我们需要先将其修改为期望的语言，这里我修改的是 zh-CN 即简体中文。 修改完后，能看到大部分地方都变成了中文，但是导航栏仍是英文。这是因为该主题并为对导航栏做国际化处理，导航栏是交由我们在 &lt;root&gt;/_config.icarus.yml 中去配置的，可以直接以汉字作为key值。 但总归是有点不舒服吧，所以想把这些东西也简单国际化一下，顺便看看是哪部分在起作用。 如果不想学jsx语法的可以直接以汉字为key值，因为涉及到部分源码的更改 在选中的语言中完善国际化配置国际化相关的文件存放在 &lt;root&gt;/themes/icarus/languages 里面，在 zh-CN.yml 添加 menu 选项（名字自定，见名知意即可） 12345678910111213141516menu: Home: one: '首页' other: '首页' Archives: one: '归档' other: '归档' Categories: one: '分类' other: '分类' Tags: one: '标签' other: '标签' About: one: '关于' other: '关于' 有其他想放上去的需要国际化的部分直接写即可，但是要记得在控制 menu 显示的地方加上对应的选项，此处针对 menu 国际化，并不控制显示与否 对于 other 还不是很明白，参考了下面原有的 common 这样，针对导航栏国际化的配置文件就补充ok了。 源码更改打开&lt;root&gt;/themes/icarus/layout/common/navbar.jsx ctrl+f 找到 Object.keys(navbar.menu) 这部分，因为主题未针对其做国际化处理，所以我们完善menu对象。对遍历做如下处理 12345678Object.keys(navbar.menu).forEach(name =&gt; { const url = url_for(navbar.menu[name]); const active = isSameLink(url, pageUrl); // __ 方法用于一般使用，_p 方法用于复数字符串使用 // 此处是通过辅助函数获取翻译后的字符串 const title = _p(`menu.${name}`) menu[name] = { title, url, active };}); 在Dom处修改显示 123456 {Object.keys(menu).length ? &lt;div class=&quot;navbar-start&quot;&gt; {Object.keys(menu).map(name =&gt; { const item = menu[name]; return &lt;a class={classname({ 'navbar-item': true, 'is-active': item.active })} href={item.url}&gt;{item.title}&lt;/a&gt;; })}&lt;/div&gt; : null} 至此，nav国际化添加完毕。","link":"/2022/10/31/%E5%85%B3%E4%BA%8E%E5%9B%BD%E9%99%85%E5%8C%96/"},{"title":"函数式触发click和点击触发click在宏任务与微任务方面的区别","text":"在做关于事件循环的分享时，注意到了这两种方式的调用结果在宏任务和微任务的执行方面有差别，特此学习记录一下 用例： 1234567891011121314// 先通过点击执行 var btn = document.querySelector('#btn') btn.addEventListener('click', ()=&gt;{ Promise.resolve().then(()=&gt;console.log(&quot;Microtask 1&quot;)); console.log(&quot;Listener 1&quot;); }) btn.addEventListener('click', ()=&gt;{ Promise.resolve().then(()=&gt;console.log(&quot;Microtask 2&quot;)); console.log(&quot;Listener 2&quot;); })// Listener 1// Microtask 1// Listener 2// Microtask 2 12345678910111213141516// 通过函数调用 var btn = document.querySelector('#btn') btn.addEventListener('click', ()=&gt;{ Promise.resolve().then(()=&gt;console.log(&quot;Microtask 1&quot;)); console.log(&quot;Listener 1&quot;); }) btn.addEventListener('click', ()=&gt;{ Promise.resolve().then(()=&gt;console.log(&quot;Microtask 2&quot;)); console.log(&quot;Listener 2&quot;); }) btn.click();// Listener 1// Listener 2// Microtask 1// Microtask 2 说一下自己的理解，在网上找了好久，并没有一个确切的描述这种结果产生的原因。上述两种结果的原因在于调用栈是否清空。也可以说是当前宏任务是否执行完毕。 点击触发当我们通过addEventListener向按钮去添加事件时，实际上是添加在了其事件侦听器列表中，可以通过getListeners去查看所有的事件。 在直接点击DOM时，会向调用栈依次添加Listener，当第一个Listener执行完后，调用栈清空。此时在下一个Listener的添加/执行之前，会先处理微任务队列，从调用栈的角度看，两个Listener属于两个不同的宏任务。具体结果就是第一个例子的 Listener1、Microtask1、Listener2、Microtask2。 函数调用在通过函数调用的时候，首先会向调用栈内添加click的调用，然后依次去执行该DOM上绑定的事件，在执行完第一个Listener中的事件后，没有return语句存在，所以click函数仍处于调用状态，调用栈并未弹出，在第二个Listener执行时仍处于同一个宏任务，所以也就有了下面的结果：Listener1、Listener2、Microtask1、、Microtask2。 补充上述说明并没有很好的资料支持，是从输出结果和Chrome控制台调用栈的显示反推的，如果有什么问题还请及时指出。","link":"/2022/10/31/%E5%87%BD%E6%95%B0%E5%BC%8F%E8%A7%A6%E5%8F%91click%E5%92%8C%E7%82%B9%E5%87%BB%E8%A7%A6%E5%8F%91click%E5%9C%A8%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"根据组件类型与条件动态添加下拉框及选项","text":"前言本次在做低代码平台时，遇见了一个稍微有些复杂的业务场景，需求描述： 根据用户拖拽表单生成的JSON数据(本次采用了FormGenerator去生成JSON数据)，生成对应的所有组件的下拉列表，并在流程图的边（节点连接线）上添加条件判断。 当用户点击流程图的边时，生成该边上对应的所有组件的下拉列表，在点击某个组件的选项后，生成对应组件的下拉列表组件，在用户取消选择后，对应组件的下拉列表组件随之消失。 针对不同组件对应的下拉列表，要求有不同的条件判断，例如：数字类型的需要有范围选择、大小判断、为空不为空，等条件；文本组件有包含不包含，等条件。 当用户选择后，自动保存到当前边对应的JSON数据，若用户的选择无效，则不保存。 要求能够回显用户选择的数据，即点击不同边时，回显该边上JSON对应的所有下拉列表组件。 经过梳理后，其实逻辑看起来也不是特别复杂，不过当时确实是有点被难倒了，主要原因就是一些细节性的问题没有考虑到，然后流程图也需要去学习如何操作，时间上有些紧，同时也在思考如何写能够更便于维护。其次就是没有一个清晰的该处业务的流程思考，不过后来捋了捋也就差不多啦，所以说三思而后行啊。 三思而后行：多思考几遍，自己又觉得自己行了哈哈 Logicflow和FromGenerator就不多说了，虽然也有点坑，但都是轮子，主要记录下这块业务场景如何实现的。 组件展示 包含所有组件的下拉列表 对应组件的下拉列表组件 根据条件改变输入形式 具体实现JSON数据处理处理JSON，不得不提一嘴ES6结构赋值，属实是属性提取的利器。原JSON大概长这个样子，为了区别不同类型的组件，和表单那边的小伙伴约定了两个字段，tag用于区分组件输入框的类型，typeNumber用于区分下拉列表内容有哪些 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302{ &quot;fields&quot;: [ { &quot;__config__&quot;: { &quot;label&quot;: &quot;单行文本&quot;, &quot;labelWidth&quot;: null, &quot;showLabel&quot;: true, &quot;changeTag&quot;: true, &quot;tag&quot;: &quot;el-input&quot;, &quot;tagIcon&quot;: &quot;input&quot;, &quot;required&quot;: true, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;span&quot;: 24, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/input&quot;, &quot;regList&quot;: [], &quot;formId&quot;: 101, &quot;renderKey&quot;: 1649927471934, &quot;typeNumber&quot;: 0 }, &quot;__slot__&quot;: { &quot;prepend&quot;: &quot;&quot;, &quot;append&quot;: &quot;&quot; }, &quot;placeholder&quot;: &quot;请输入单行文本&quot;, &quot;style&quot;: { &quot;width&quot;: &quot;100%&quot; }, &quot;clearable&quot;: true, &quot;prefix-icon&quot;: &quot;&quot;, &quot;suffix-icon&quot;: &quot;&quot;, &quot;maxlength&quot;: null, &quot;show-word-limit&quot;: false, &quot;readonly&quot;: false, &quot;disabled&quot;: false, &quot;__vModel__&quot;: &quot;field101&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;多行文本&quot;, &quot;labelWidth&quot;: null, &quot;showLabel&quot;: true, &quot;tag&quot;: &quot;el-input&quot;, &quot;tagIcon&quot;: &quot;textarea&quot;, &quot;required&quot;: true, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;span&quot;: 24, &quot;regList&quot;: [], &quot;changeTag&quot;: true, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/input&quot;, &quot;formId&quot;: 102, &quot;typeNumber&quot;: 1, &quot;renderKey&quot;: 1649927472786 }, &quot;type&quot;: &quot;textarea&quot;, &quot;placeholder&quot;: &quot;请输入多行文本&quot;, &quot;autosize&quot;: { &quot;minRows&quot;: 4, &quot;maxRows&quot;: 4 }, &quot;style&quot;: { &quot;width&quot;: &quot;100%&quot; }, &quot;maxlength&quot;: null, &quot;show-word-limit&quot;: false, &quot;readonly&quot;: false, &quot;disabled&quot;: false, &quot;__vModel__&quot;: &quot;field102&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;级联选择&quot;, &quot;showLabel&quot;: true, &quot;labelWidth&quot;: null, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;tagIcon&quot;: &quot;cascader&quot;, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;defaultValue&quot;: [ 1, 2 ], &quot;dataType&quot;: &quot;dynamic&quot;, &quot;span&quot;: 24, &quot;required&quot;: true, &quot;regList&quot;: [], &quot;changeTag&quot;: true, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/cascader&quot;, &quot;formId&quot;: 111, &quot;typeNumber&quot;: 9, &quot;renderKey&quot;: 1649942215947 }, &quot;options&quot;: [ { &quot;id&quot;: 1, &quot;value&quot;: 1, &quot;label&quot;: &quot;选项1&quot;, &quot;children&quot;: [ { &quot;id&quot;: 2, &quot;value&quot;: 2, &quot;label&quot;: &quot;选项1-1&quot; } ] } ], &quot;placeholder&quot;: &quot;请选择级联选择&quot;, &quot;style&quot;: { &quot;width&quot;: &quot;100%&quot; }, &quot;props&quot;: { &quot;props&quot;: { &quot;multiple&quot;: false, &quot;label&quot;: &quot;label&quot;, &quot;value&quot;: &quot;value&quot;, &quot;children&quot;: &quot;children&quot; } }, &quot;show-all-levels&quot;: true, &quot;disabled&quot;: false, &quot;clearable&quot;: true, &quot;filterable&quot;: false, &quot;separator&quot;: &quot;/&quot;, &quot;__vModel__&quot;: &quot;field111&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;计数器&quot;, &quot;showLabel&quot;: true, &quot;changeTag&quot;: true, &quot;labelWidth&quot;: null, &quot;tag&quot;: &quot;el-input-number&quot;, &quot;tagIcon&quot;: &quot;number&quot;, &quot;span&quot;: 24, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;required&quot;: true, &quot;regList&quot;: [], &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/input-number&quot;, &quot;formId&quot;: 105, &quot;typeNumber&quot;: 2, &quot;renderKey&quot;: 1649927477883 }, &quot;placeholder&quot;: &quot;计数器&quot;, &quot;step&quot;: 1, &quot;step-strictly&quot;: false, &quot;controls-position&quot;: &quot;&quot;, &quot;disabled&quot;: false, &quot;__vModel__&quot;: &quot;field105&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;下拉选择&quot;, &quot;showLabel&quot;: true, &quot;labelWidth&quot;: null, &quot;tag&quot;: &quot;el-select&quot;, &quot;tagIcon&quot;: &quot;select&quot;, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;span&quot;: 24, &quot;required&quot;: true, &quot;regList&quot;: [], &quot;changeTag&quot;: true, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/select&quot;, &quot;formId&quot;: 106, &quot;typeNumber&quot;: 6, &quot;renderKey&quot;: 1649927484505 }, &quot;__slot__&quot;: { &quot;options&quot;: [ { &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 } ] }, &quot;placeholder&quot;: &quot;请选择下拉选择&quot;, &quot;style&quot;: { &quot;width&quot;: &quot;100%&quot; }, &quot;clearable&quot;: true, &quot;disabled&quot;: false, &quot;filterable&quot;: false, &quot;multiple&quot;: false, &quot;__vModel__&quot;: &quot;field106&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;单选框组&quot;, &quot;labelWidth&quot;: null, &quot;showLabel&quot;: true, &quot;tag&quot;: &quot;el-radio-group&quot;, &quot;tagIcon&quot;: &quot;radio&quot;, &quot;changeTag&quot;: true, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;span&quot;: 24, &quot;optionType&quot;: &quot;default&quot;, &quot;regList&quot;: [], &quot;required&quot;: true, &quot;border&quot;: false, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/radio&quot;, &quot;formId&quot;: 107, &quot;typeNumber&quot;: 4, &quot;renderKey&quot;: 1649927491036 }, &quot;__slot__&quot;: { &quot;options&quot;: [ { &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 } ] }, &quot;style&quot;: {}, &quot;size&quot;: &quot;medium&quot;, &quot;disabled&quot;: false, &quot;__vModel__&quot;: &quot;field107&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;多选框组&quot;, &quot;tag&quot;: &quot;el-checkbox-group&quot;, &quot;tagIcon&quot;: &quot;checkbox&quot;, &quot;defaultValue&quot;: [], &quot;span&quot;: 24, &quot;showLabel&quot;: true, &quot;labelWidth&quot;: null, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;optionType&quot;: &quot;default&quot;, &quot;required&quot;: true, &quot;regList&quot;: [], &quot;changeTag&quot;: true, &quot;border&quot;: false, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/checkbox&quot;, &quot;formId&quot;: 108, &quot;typeNumber&quot;: 5, &quot;renderKey&quot;: 1649927491380 }, &quot;__slot__&quot;: { &quot;options&quot;: [ { &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 } ] }, &quot;style&quot;: {}, &quot;size&quot;: &quot;medium&quot;, &quot;disabled&quot;: false, &quot;__vModel__&quot;: &quot;field108&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;日期选择&quot;, &quot;tag&quot;: &quot;el-date-picker&quot;, &quot;tagIcon&quot;: &quot;date&quot;, &quot;defaultValue&quot;: null, &quot;showLabel&quot;: true, &quot;labelWidth&quot;: null, &quot;span&quot;: 24, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;required&quot;: true, &quot;regList&quot;: [], &quot;changeTag&quot;: true, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/date-picker&quot;, &quot;formId&quot;: 110, &quot;typeNumber&quot;: 3, &quot;renderKey&quot;: 1649927506700 }, &quot;placeholder&quot;: &quot;请选择日期选择&quot;, &quot;type&quot;: &quot;date&quot;, &quot;style&quot;: { &quot;width&quot;: &quot;100%&quot; }, &quot;disabled&quot;: false, &quot;clearable&quot;: true, &quot;format&quot;: &quot;yyyy-MM-dd&quot;, &quot;value-format&quot;: &quot;yyyy-MM-dd&quot;, &quot;readonly&quot;: false, &quot;__vModel__&quot;: &quot;field110&quot; } ], &quot;formRef&quot;: &quot;elForm&quot;, &quot;formModel&quot;: &quot;formData&quot;, &quot;size&quot;: &quot;medium&quot;, &quot;labelPosition&quot;: &quot;right&quot;, &quot;labelWidth&quot;: 100, &quot;formRules&quot;: &quot;rules&quot;, &quot;gutter&quot;: 15, &quot;disabled&quot;: false, &quot;span&quot;: 24, &quot;formBtns&quot;: true, &quot;unFocusedComponentBorder&quot;: false} 解构工具类解构赋值 过滤数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204// utils/adpterForForm.js// 依照tag判断组件输入框的类型(FormGenerator采用的elementui，所以会有el-xxx的tag)const contentTypeMap = { 'el-input': 'input', 'el-textarea': 'input', 'el-input-number': 'input', 'el-date-picker': 'date', 'el-radio-group': 'select', 'el-checkbox-group': 'select', 'el-select': 'select', 'el-cascader': 'tree', 'el-upload': 'none'};// { label: '等于', value: 0 },// { label: '不等于', value: 1 },// { label: '包含', value: 2 },// { label: '不包含', value: 3 },// { label: '为空', value: 4 },// { label: '不为空', value: 5 }// { label: '大于', value: 6 },// { label: '大于等于', value: 7 },// { label: '小于', value: 8 },// { label: '小于等于', value: 9 },// { label: '选择范围', value: 10 },// { label: '等于任意一个', value: 11 },// { label: '不等于任意一个', value: 12 },// { label: '包含任意一个', value: 13 },// { label: '同时包含', value: 14 },// { label: '属于', value: 15 },// { label: '不属于', value: 16 },// { label: '已验证', value: 17 },// { label: '未验证', value: 18 },// 依照type判断组件所对应的下拉列表const judgeListMap = { // 单行文本 '0': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '包含', value: 2 }, { label: '不包含', value: 3 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 多行文本 '1': [ { label: '包含', value: 2 }, { label: '不包含', value: 3 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 数字 '2': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '大于', value: 6 }, { label: '大于等于', value: 7 }, { label: '小于', value: 8 }, { label: '小于等于', value: 9 }, { label: '选择范围', value: 10 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 日期时间 '3': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '大于等于', value: 7 }, { label: '小于等于', value: 9 }, { label: '选择范围', value: 10 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 单选按钮组 '4': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '等于任意一个', value: 11 }, { label: '不等于任意一个', value: 12 }, { label: '包含', value: 2 }, { label: '不包含', value: 3 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 复选框组 '5': [ { label: '等于', value: 0 }, { label: '包含任意一个', value: 13 }, { label: '同时包含', value: 14 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 单选列表 '6': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '等于任意一个', value: 11 }, { label: '不等于任意一个', value: 12 }, { label: '包含', value: 2 }, { label: '不包含', value: 3 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 复选列表 '7': [ { label: '等于', value: 0 }, { label: '包含任意一个', value: 13 }, { label: '同时包含', value: 14 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 地址 '9': [ { label: '属于', value: 15 }, { label: '不属于', value: 16 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 图片 '10': [ { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 附件 '11': [ { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 手机 '12': [ { label: '包含', value: 2 }, { label: '已验证', value: 17 }, { label: '未验证', value: 18 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 成员单选 '13': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '等于任意一个', value: 11 }, { label: '不等于任意一个', value: 12 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 成员多选 '14': [ { label: '等于', value: 0 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 }, { label: '包含任意一个', value: 13 }, { label: '同时包含', value: 14 } ], // 成员单选 '15': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '等于任意一个', value: 11 }, { label: '不等于任意一个', value: 12 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 部门多选 '16': [ { label: '等于', value: 0 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 }, { label: '包含任意一个', value: 13 }, { label: '同时包含', value: 14 } ]};// 获取表单JSON数据中所有组件的必要信息，并存放在map中去，便于查询和管理export function getComponentMap (data) { // 声明一个map集合 const map = new Map(); // 遍历解构赋值每一项 for (const item of data) { const { '__config__': { 'label': label = '', 'renderKey': renderKey = '', 'tag': tag = '', 'typeNumber': type = '' }, '__slot__': { 'options': options = [] } = {} } = item; // 构造所需要的数据对象 const obj = { label: label, renderKey: renderKey, // 唯一标识 tag: tag, // 决定条件组件卡片的内容选择形式，因为文本输入框和数字、日期的展示形式不同 type: type, // 决定条件卡片的条件选项有哪些 options: options // 如果内容选项为下拉列表时，通过options展示 }; obj.judgeList = judgeListMap[obj.type]; // 依照type添加条件列表 obj.componentFormat = contentTypeMap[obj.tag]; // 依照tag添加内容展示形式 map.set(obj.renderKey, obj); // 依据组件的唯一标识去存放进map } return map;} 解构结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473[{ &quot;key&quot;: &quot;1011655792483713&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;单行文本&quot;, &quot;renderKey&quot;: &quot;1011655792483713&quot;, &quot;tag&quot;: &quot;el-input&quot;, &quot;type&quot;: 0, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;包含&quot;, &quot;value&quot;: 2 }, { &quot;label&quot;: &quot;不包含&quot;, &quot;value&quot;: 3 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;input&quot; }}, { &quot;key&quot;: &quot;1021655792484018&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;多行文本&quot;, &quot;renderKey&quot;: &quot;1021655792484018&quot;, &quot;tag&quot;: &quot;el-input&quot;, &quot;type&quot;: 1, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;包含&quot;, &quot;value&quot;: 2 }, { &quot;label&quot;: &quot;不包含&quot;, &quot;value&quot;: 3 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;input&quot; }}, { &quot;key&quot;: &quot;1031655792484335&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;数字&quot;, &quot;renderKey&quot;: &quot;1031655792484335&quot;, &quot;tag&quot;: &quot;el-input&quot;, &quot;type&quot;: 2, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;大于&quot;, &quot;value&quot;: 6 }, { &quot;label&quot;: &quot;大于等于&quot;, &quot;value&quot;: 7 }, { &quot;label&quot;: &quot;小于&quot;, &quot;value&quot;: 8 }, { &quot;label&quot;: &quot;小于等于&quot;, &quot;value&quot;: 9 }, { &quot;label&quot;: &quot;选择范围&quot;, &quot;value&quot;: 10 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;input&quot; }}, { &quot;key&quot;: &quot;1041655792484586&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;日期时间&quot;, &quot;renderKey&quot;: &quot;1041655792484586&quot;, &quot;tag&quot;: &quot;el-date-picker&quot;, &quot;type&quot;: 3, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;大于等于&quot;, &quot;value&quot;: 7 }, { &quot;label&quot;: &quot;小于等于&quot;, &quot;value&quot;: 9 }, { &quot;label&quot;: &quot;选择范围&quot;, &quot;value&quot;: 10 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;date&quot; }}, { &quot;key&quot;: &quot;1051655792484934&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;单选按钮组&quot;, &quot;renderKey&quot;: &quot;1051655792484934&quot;, &quot;tag&quot;: &quot;el-radio-group&quot;, &quot;type&quot;: 4, &quot;options&quot;: [{ &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 }], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;等于任意一个&quot;, &quot;value&quot;: 11 }, { &quot;label&quot;: &quot;不等于任意一个&quot;, &quot;value&quot;: 12 }, { &quot;label&quot;: &quot;包含&quot;, &quot;value&quot;: 2 }, { &quot;label&quot;: &quot;不包含&quot;, &quot;value&quot;: 3 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;select&quot; }}, { &quot;key&quot;: &quot;1061655792485183&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;复选框组&quot;, &quot;renderKey&quot;: &quot;1061655792485183&quot;, &quot;tag&quot;: &quot;el-checkbox-group&quot;, &quot;type&quot;: 5, &quot;options&quot;: [{ &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 }], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;包含任意一个&quot;, &quot;value&quot;: 13 }, { &quot;label&quot;: &quot;同时包含&quot;, &quot;value&quot;: 14 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;select&quot; }}, { &quot;key&quot;: &quot;1071655792485471&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;下拉框&quot;, &quot;renderKey&quot;: &quot;1071655792485471&quot;, &quot;tag&quot;: &quot;el-select&quot;, &quot;type&quot;: 6, &quot;options&quot;: [{ &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 }], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;等于任意一个&quot;, &quot;value&quot;: 11 }, { &quot;label&quot;: &quot;不等于任意一个&quot;, &quot;value&quot;: 12 }, { &quot;label&quot;: &quot;包含&quot;, &quot;value&quot;: 2 }, { &quot;label&quot;: &quot;不包含&quot;, &quot;value&quot;: 3 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;select&quot; }}, { &quot;key&quot;: &quot;1081655792485723&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;下拉复选框&quot;, &quot;renderKey&quot;: &quot;1081655792485723&quot;, &quot;tag&quot;: &quot;el-select&quot;, &quot;type&quot;: 7, &quot;options&quot;: [{ &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 }], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;包含任意一个&quot;, &quot;value&quot;: 13 }, { &quot;label&quot;: &quot;同时包含&quot;, &quot;value&quot;: 14 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;select&quot; }}, { &quot;key&quot;: &quot;1091655792486011&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;分割线&quot;, &quot;renderKey&quot;: &quot;1091655792486011&quot;, &quot;tag&quot;: &quot;el-divider&quot;, &quot;type&quot;: 8, &quot;options&quot;: [], &quot;judgeList&quot;: &quot;__vue_devtool_undefined__&quot;, &quot;componentFormat&quot;: &quot;__vue_devtool_undefined__&quot; }}, { &quot;key&quot;: &quot;1101655792486384&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;地址&quot;, &quot;renderKey&quot;: &quot;1101655792486384&quot;, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;type&quot;: 9, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;属于&quot;, &quot;value&quot;: 15 }, { &quot;label&quot;: &quot;不属于&quot;, &quot;value&quot;: 16 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;tree&quot; }}, { &quot;key&quot;: &quot;1111655792487022&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;附件&quot;, &quot;renderKey&quot;: &quot;1111655792487022&quot;, &quot;tag&quot;: &quot;el-upload&quot;, &quot;type&quot;: 11, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;none&quot; }}, { &quot;key&quot;: &quot;1121655792487317&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;图片&quot;, &quot;renderKey&quot;: &quot;1121655792487317&quot;, &quot;tag&quot;: &quot;el-upload&quot;, &quot;type&quot;: 10, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;none&quot; }}, { &quot;key&quot;: &quot;1131655792487550&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;手机&quot;, &quot;renderKey&quot;: &quot;1131655792487550&quot;, &quot;tag&quot;: &quot;el-input&quot;, &quot;type&quot;: 12, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;包含&quot;, &quot;value&quot;: 2 }, { &quot;label&quot;: &quot;已验证&quot;, &quot;value&quot;: 17 }, { &quot;label&quot;: &quot;未验证&quot;, &quot;value&quot;: 18 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;input&quot; }}, { &quot;key&quot;: &quot;1141655792487891&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;成员单选&quot;, &quot;renderKey&quot;: &quot;1141655792487891&quot;, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;type&quot;: 13, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;等于任意一个&quot;, &quot;value&quot;: 11 }, { &quot;label&quot;: &quot;不等于任意一个&quot;, &quot;value&quot;: 12 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;tree&quot; }}, { &quot;key&quot;: &quot;1151655792488133&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;部门单选&quot;, &quot;renderKey&quot;: &quot;1151655792488133&quot;, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;type&quot;: 15, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;等于任意一个&quot;, &quot;value&quot;: 11 }, { &quot;label&quot;: &quot;不等于任意一个&quot;, &quot;value&quot;: 12 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;tree&quot; }}, { &quot;key&quot;: &quot;1161655792488389&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;部门多选&quot;, &quot;renderKey&quot;: &quot;1161655792488389&quot;, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;type&quot;: 16, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }, { &quot;label&quot;: &quot;包含任意一个&quot;, &quot;value&quot;: 13 }, { &quot;label&quot;: &quot;同时包含&quot;, &quot;value&quot;: 14 }], &quot;componentFormat&quot;: &quot;tree&quot; }}, { &quot;key&quot;: &quot;1171655792488689&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;成员多选&quot;, &quot;renderKey&quot;: &quot;1171655792488689&quot;, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;type&quot;: 14, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }, { &quot;label&quot;: &quot;包含任意一个&quot;, &quot;value&quot;: 13 }, { &quot;label&quot;: &quot;同时包含&quot;, &quot;value&quot;: 14 }], &quot;componentFormat&quot;: &quot;tree&quot; }}] 至此，我们就满足了业务流程中的第 1 点和第 3 点： 根据用户拖拽表单生成的JSON数据(本次采用了FormGenerator去生成JSON数据)，生成对应的所有组件的下拉列表，并在流程图的连接线上添加条件判断。 针对不同组件对应的下拉列表，要求有不同的条件判断，例如：数字类型的需要有范围选择、大小判断、为空不为空，等条件；文本组件有包含不包含，等条件 我们只需提取map中每个组件的renderKey和label作为选项的value和label即可生成所有组件的下拉列表。当然，不要忘了用JSON.parse解析JSON对象后再提取 生成/删除单个下拉列表组件来让我们看看第2个流程： 当用户点击流程图的边时，生成该边上对应的所有组件的下拉列表，在点击某个组件的选项后，生成对应组件的下拉列表组件，在用户取消选择后，对应组件的下拉列表组件随之消失。 我们借鉴Vue的思想，给这个增增删删的组件一个生命周期，那么他大概分为如下几个生命周期： init：点击流程图时，属于init初始化的阶段，判断是否有回显的数据，并组织各类数据去展示。 首先初始化该边的数据，由父组件传递过来，然后判断是否有数据需要回显（initEdgeData） 当边的数据初始化结束后，假如没有数据需要回显，则结束init。否则，添加回显的数据item进已选项中（initSelectedItems） 当选中项存在时，需要初始化选中项对应的组件（initSelectedComponents） update：当已选组件列表发生变化时，更新下拉列表组件 如果是在全部组件列表里添加了新选项，那么就需要将其由renderKey和label的item添加进已选项中 如果是取消了某个选项，删除该选项renderKey对应的数据 如果是更新了已选项的数据，判断是否应该被保存 distory：当全部组件列表的某个已选项取消选择后，删除对应的下拉列表组件。触发update。所以这个阶段可以和update合二为一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190//所有组件下拉列表的vue结构 &lt;!-- 添加流转条件多选列表 --&gt; &lt;el-select v-model=&quot;selectedComponentIds&quot; size=&quot;small&quot; :popper-append-to-body=&quot;false&quot; collapse-tags filterable multiple placeholder=&quot;请选择&quot; @change=&quot;updateSelectedComponents&quot; &gt; &lt;el-option v-for=&quot;item in formComponents&quot; :key=&quot;item.renderKey&quot; :label=&quot;item.label&quot; :value=&quot;item.renderKey&quot; /&gt; &lt;/el-select&gt;// 遍历展示下拉组件的vue结构 &lt;div class=&quot;conditions-items-box&quot;&gt; &lt;!-- key值不同保证更新子组件的值 --&gt; &lt;componentsCard v-for=&quot;item in selectedComponentsAry&quot; :key=&quot;JSON.stringify(item.condition)&quot; :custom-component=&quot;item&quot; :cur-judge=&quot;curJudge&quot; @changeCurJudge=&quot;showJudge&quot; @saveComponent=&quot;saveComponent&quot; /&gt; &lt;/div&gt;&lt;script&gt;import componentsCard from '@/components/workflow/PropertySetting/componentsCard';import { getComponentMap } from '@/utils/adpterForForm';components: { componentsCard },data() { return { conditionOptions: [{ value: 0, label: '使用自定义流转条件' }, { value: 1, label: '使用Else条件' }], choseType: false, isAll: false, selectedCondition: 0, formComponents: [], // 用于遍历展示所有组件的选项列表 componentsMap: null, // 存放所有组件的基础信息 selectedComponentIds: [], // 存放所有已选组件的renderKey（唯一id） selectedComponentsAry: null, // 遍历展示每个组件下拉列表组件 curJudge: -1, form: null, // 拷贝当前边的自定义数据 saveMap: new Map() // 仅保存conditions，这是后端要求的，即renderKey、Judge、content }; },// 通过watch监听边的变化并获取数据watch: { // 边更新后初始化数据 nodeData: function(val) { if (val.type === 'customEdge') { this.initEdgeData(val); } } },// Vue组件初始化时created() { // 构建组件map，key为renderKey，value为组件所有的基本信息 // 把表单数据存在了localStorage里面防止刷新页面后表单数据丢失 this.componentsMap = getComponentMap(JSON.parse(window.localStorage.drawingItems)); // 获取表单数据并展示选择列表。这里就是v-for展示下拉选项用的 this.formComponents = [...this.componentsMap.values()]; // 此处可以优化，只用到了label和renderKey，存在一个数据冗余的问题 可以遍历解构label和value。 }, methods:{ // 初始化边的条件数据 initEdgeData(data) { // 提取边的自定义属性properties，并拷贝一份到当前实例（不需要深拷贝） // 便于在保存数据时直接拿来save替换掉老数据 // 保存的数据都存在properties.conditions里面 const { properties } = data; if (properties) { this.$data.form = Object.assign({}, this.$data.form, properties); } // 更新当前选中项 this.initSelectedItems(data); // 更新当前选中项对应的自定义组件 this.initSelectedComponents(this.$data.form.conditions); }, // 初始化选中项 initSelectedItems(data) { // 初始化选中项数组。 this.selectedComponentIds = []; // 将边上之前添加过的数据回显出来 data.properties.conditions.forEach(item =&gt; { this.selectedComponentIds.push(item.renderKey); }); }, // 初始化选中项对应的组件，此时除了初始化组件的基本信息外，还会添加已选组件的用户输入信息，即conditionList initSelectedComponents(conditionList) { const ary = []; // 遍历当前选中项，更新条件map和卡片数组 for (const item of conditionList) { // 此处需要深拷贝，componentsMap获取的是一份地址，直接操作会污染componentsMap const componentObj = Object.create(this.componentsMap.get(item.renderKey)); componentObj.condition = item; ary.push(componentObj); // 初始化要保存的map，map保存的仅有conditions，这是后端要求的 /* conditions形如 *{ * renderKey:唯一id * Judge:条件 * content:内容 *} */ this.saveMap.set(item.renderKey, item); } // 更新当前选中项对应的组件卡片数组 this.selectedComponentsAry = ary; }, // 更新当前选中项对应的组件 // 此方法在触发下拉列表事@change件时传入已选项的renderKey的list // 使用renderKey，控制条件组件的展示 updateSelectedComponents(idList) { const ary = []; // 用于遍历展示用的已选项数组 const newSaveMap = new Map(); // 用于替换saveMap的新map，数据格式和saveMap一样，是update后的saveMap let saveMapItem = null; // 判断是否已存在该数据，是延用数据还是初始化保存项 // 遍历当前选中项，更新newSaveMap和卡片数组 // item为renderKey（唯一id） for (const item of idList) { // 此处需要浅拷贝，直接操作会污染componentsMap（组件的基本信息） const componentObj = Object.create(this.componentsMap.get(item)); // 目标组件的基本信息 saveMapItem = this.saveMap.get(item); // 向组件添加要入库的condition信息，即用户输入的信息 // 同时判断该数据是否已存在，是延用数据还是初始化数据 // 这么做的原因是因为无法获取到最新添加/删除的id，只能获得所有的id，然后遍历替换数据，所以已存在的老数据需要保留 componentObj.condition = saveMapItem ? saveMapItem : { Judge: -1, // 条件默认为 请选择 content: null, // 选择的内容默认为 null renderKey: item // 唯一id }; ary.push(componentObj); // 用于遍历展示用的已选项数组 newSaveMap.set(item, this.saveMap.get(item)); // 向准备替换的map内添加数据 } // 更新要存入节点的map this.saveMap = newSaveMap; this.form.conditions = this.filterSaveData(); // 更新当前选中项对应的组件卡片数组 this.selectedComponentsAry = ary; this.saveData(); }, // 新添加的下拉列表组件值被修改后触发 saveComponent(conditions) { const { Judge: judge, renderKey } = conditions; if (judge !== -1) { this.saveMap.set(renderKey, conditions); } this.form.conditions = this.filterSaveData(); this.saveData(); } // 过滤可保存数据 filterSaveData() { this.form.conditions = [...this.saveMap.values()].filter(item =&gt; { if (item &amp;&amp; item.judge !== -1) { // 选择了条件 if (item.judge === 4 || item.judge === 5) { // 条件是 为空 和 不为空 不需要content有值 return item; } else if (item.content !== '' &amp;&amp; item.content !== null &amp;&amp; item.content !== undefined) { // 其他条件content必须有值才通过过滤 return item; } } }); }, // 保存数据到当前选中元素 saveData() { const { id } = this.$props.nodeData; // logicFlow的保存节点信息的Api this.$props.lf.setProperties(id, this.$data.form); }, } &lt;/script&gt; 至此，我们已经完成了流程2的所有逻辑。 当用户点击流程图的边时，生成该边上对应的所有组件的下拉列表，在点击某个组件的选项后，生成对应组件的下拉列表组件，在用户取消选择后，对应组件的下拉列表组件随之消失。 因为流程3的逻辑在我们编写工具类时就已经搞定了，所以进入流程4 当用户选择后，自动保存到当前边对应的JSON数据，若用户的选择无效，则不保存 子组件的编写+数据保存子组件采用工厂模式写了一个工厂组件，这里起得名字叫componentsCard，通过组件内部的componentFormat属性决定该组件该如何展示。该属性在解构的时候通过tag属性添加。 当用户在全部组件的下拉列表选择后，该组件的renderKey就会被添加进已选项中，假如用户并没有进行任何操作，则该条数据会被filterSaveData过滤掉，被认为是无效数据。只有满足filterSaveData过滤条件的数据才会被存入当前边的JSON数据中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208// 只展示了部分关键代码 .... &lt;div class=&quot;container-title&quot;&gt; &lt;div class=&quot;title-name&quot;&gt; {{ customComponent.label }} &lt;/div&gt; &lt;div class=&quot;title-conditions&quot; @click=&quot;showJudgeList(customComponent)&quot;&gt; {{ selectedItem.label }} &lt;i class=&quot;icon-wf-caretdown iconfont&quot; /&gt; &lt;div v-if=&quot;+curJudge === +customComponent.renderKey&quot; class=&quot;list-box&quot;&gt; &lt;div v-for=&quot;(item,index) in customComponent.judgeList &quot; :key=&quot;index&quot; class=&quot;list-item&quot; @click.capture.stop=&quot;selectItem(item)&quot; &gt; {{ item.label }} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ....&lt;!-- 为空或不为空作为条件时，该选项不显示 --&gt; &lt;div v-show=&quot;showContent&quot;&gt; &lt;div v-if=&quot;customComponent.componentFormat === 'input'&quot; class=&quot;content&quot; &gt; &lt;el-input v-show=&quot;selectedItem.value !== 4 &amp;&amp; selectedItem.value !== 5&quot; v-model=&quot;content&quot; @change=&quot;saveData&quot; /&gt; &lt;/div&gt; &lt;div v-if=&quot;customComponent.componentFormat === 'select'&quot; class=&quot;content&quot; &gt; &lt;!-- 单选列表 --&gt; &lt;el-select v-show=&quot;!isMultipleSelect&quot; v-model=&quot;content&quot; @change=&quot;saveData&quot; &gt; &lt;el-option v-for=&quot;item in customComponent.options&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot; /&gt; &lt;/el-select&gt; &lt;!-- 多选列表 --&gt; &lt;el-select v-show=&quot;isMultipleSelect&quot; v-model=&quot;contentAry&quot; multiple placeholder=&quot;请选择&quot; @change=&quot;saveDataAry&quot; &gt; &lt;el-option v-for=&quot;item in customComponent.options&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot; /&gt; &lt;/el-select&gt; &lt;/div&gt; &lt;div v-if=&quot;customComponent.componentFormat === 'date'&quot; class=&quot;content&quot; &gt; &lt;el-date-picker v-show=&quot;!isRange&quot; v-model=&quot;content&quot; type=&quot;date&quot; placeholder=&quot;选择日期&quot; value-format=&quot;timestamp&quot; @change=&quot;saveData&quot; /&gt; &lt;el-date-picker v-show=&quot;isRange&quot; v-model=&quot;contentAry&quot; type=&quot;daterange&quot; range-separator=&quot;~&quot; value-format=&quot;timestamp&quot; @change=&quot;saveDataAry&quot; /&gt; &lt;/div&gt; &lt;div v-if=&quot;customComponent.componentFormat === 'tree'&quot; class=&quot;content&quot; &gt; &lt;el-cascader v-model=&quot;content&quot; :options=&quot;customComponent.options&quot; @change=&quot;saveData&quot; /&gt; &lt;/div&gt; &lt;div v-if=&quot;customComponent.componentFormat === 'none'&quot; class=&quot;content&quot; /&gt; &lt;/div&gt; &lt;script&gt;export default { props: { curJudge: { type: Number, default: -1 }, customComponent: { type: Object, default: () =&gt; {} } }, data() { return { selectedItem: { label: '请选择', value: -1 }, // 条件字段选择的item content: '', // 内容 contentAry: [], // 内容也可能是数组（范围选择时） multipleSelectVal: [2, 3, 11, 12, 13, 14], // 这些值表示可以进行多选 rangeVal: [10] // 这些值表示是范围选择, }; }, computed: { // 要保存的数据 sendData: function() { return { content: this.content, renderKey: this.customComponent.renderKey, Judge: this.selectedItem.value }; }, sendDataAry: function() { return { content: this.contentAry, renderKey: this.customComponent.renderKey, Judge: this.selectedItem.value }; }, // 是否展示输入框 showContent: function() { return this.selectedItem.value !== 4 &amp;&amp; this.selectedItem.value !== 5; }, // 是否多选 isMultipleSelect: function() { return this.findVal(this.multipleSelectVal, this.selectedItem.value); }, // 是否范围选择 isRange: function() { return this.findVal(this.rangeVal, this.selectedItem.value); } }, mounted() { // 判断显示的内容是 数组 还是 字符串/数字 Array.isArray(this.customComponent.condition.content) ? this.contentAry = this.customComponent.condition.content : this.content = this.customComponent.condition.content; // 已选值传入时需要回显，找到对应的选项 const initSelectJudge = this.customComponent.judgeList.find(options =&gt; { return options.value === this.customComponent.condition.Judge; }); // 初始化当前组件条件选项的值 this.selectedItem = initSelectJudge || this.selectedItem; }, methods: { selectItem(item) { this.selectedItem = item; // 选择完关闭条件列表 this.$emit('changeCurJudge', -1); this.content = null; this.contentAry = null; // 这里将数据是否保存的判断全部交由父组件去处理了，这里本来是只有选择 为空/不为空 才会发送 // 原因1 // 数据保存的条件是blur，所以当更改数据后就需要确认数据是否能够被保存（这里和流程图的设计有关） // 原因2 // 但即使父组件接收到了数据，也需要额外的判断流程，不如就将所有的判断逻辑都交由了父组件处理 // 这样子组件只管选择就行了，后期即使需要更改也只需要更改父组件的判断逻辑 // 原因3 // 这样在用户切换条件时，能够重置输入框 this.$emit('saveComponent', this.sendData); }, showJudgeList(item) { this.$emit('changeCurJudge', item.renderKey); }, // 保存数据，通过计算属性包装的data直接发送 saveData(val) { this.content = val; this.$emit('saveComponent', this.sendData); }, // 保存数据，通过计算属性包装的data直接发送 saveDataAry(val) { this.contentAry = val; this.$emit('saveComponent', this.sendDataAry); }, // 工具方法，找数用的 findVal(ary, val) { return ary.find(item =&gt; { return item === val; }); } }};&lt;/script&gt; 这样子组件就可以在数据更改后向父组件通知，并将所有的判断逻辑交由父组件处理，将子组件的功能尽量简化。避免后期在维护时还需要关注子组件的判断逻辑。 而且通过工厂组件，当需要新加组件时也只需要去维护一个componentCard组件就行了，逻辑完全可以复用。 到这，业务流程4就能跑通了。 当用户选择后，自动保存到当前边对应的JSON数据，若用户的选择无效，则不保存。 至于业务流程5 要求能够回显用户选择的数据，即点击不同边时，回显该边上JSON对应的所有下拉列表组件 因为在父组件使用了watch，当节点发生变化时，会重新执行init阶段的各种方法，从而做到数据回显。 总结做这种组件还是需要理清楚逻辑，多多关注细节问题。同时尽量让逻辑简单起来。当然肯定存在不少更优的写法，不过目前还考虑不到，欢迎各位大佬评论指正。","link":"/2022/10/31/%E6%A0%B9%E6%8D%AE%E7%BB%84%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E4%B8%8B%E6%8B%89%E6%A1%86%E5%8F%8A%E9%80%89%E9%A1%B9/"},{"title":"秒杀倒计时（准确计时）","text":"最近在准备事件循环的分享时，对于如何实现准确的计时有了点兴趣，因为在浏览器中，setTimeout/setInterval 并不是一个准确的计时，是存在延迟的。那么思考我们在双十一抢东西的场景，他们是如何做倒计时的呢？ 方案1确认服务端与客户端的时间差 首先，时间肯定是按服务器的时间 serverTime 为主，客户端通过通过请求接口获取服务端的时间。运营取设置开始时间 startTime 运营需要设置startTime，通过startTime与serverTime相减即为活动在各个手机上的真实的剩余时间。 因为前端在进行 setTimeout 或 setInterval 时，会有时间的偏差，所以需要在该阶段消除误差。可以在执行新的 setTimeout 时将误差考虑进去，进行提前执行（一般都是1000ms更新一次）1234567891011121314151617181920212223242526272829//继续线程占用setInterval(function(){ var j = 0; while(j++ &lt; 100000000); }, 0); //倒计时var interval = 1000, ms = 50000, //从服务器和活动开始时间计算出的时间差，这里测试用50000ms count = 0, startTime = new Date().getTime();if( ms &gt;= 0){ var timeCounter = setTimeout(countDownStart,interval); } function countDownStart(){ count++; var offset = new Date().getTime() - (startTime + count * interval); var nextTime = interval - offset; var daytohour = 0; if (nextTime &lt; 0) { nextTime = 0 }; ms -= interval; console.log(&quot;误差：&quot; + offset + &quot;ms，下一次执行：&quot; + nextTime + &quot;ms后，离活动开始还有：&quot; + ms + &quot;ms&quot;); if(ms &lt; 0){ clearTimeout(timeCounter); }else{ timeCounter = setTimeout(countDownStart,nextTime); } } 当阻塞过长的时候，需要另外处理。 方案2使用requestAnimationFrame每16.7ms执行一次，但是也会存在不准确的情况本质上是将函数作为requestAnimationFrame的回调去执行以实现计时效果（函数内部继续执行requestAnimationFrame，并将函数自己传入） 方案3使用webWorker利用worker去处理计时，思路和方案1类似。","link":"/2022/10/31/%E7%A7%92%E6%9D%80%E5%80%92%E8%AE%A1%E6%97%B6%EF%BC%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%86%E7%A1%AE%E8%AE%A1%E6%97%B6%EF%BC%89/"},{"title":"设计模式：单例模式","text":"前言学习了这么长的时间，设计模式却还是浅尝辄止，而且最近在回顾Vue知识的时候，发现了很多常见的设计模式：观察者啊，单例啊什么的。让我意识到，如果想要去读懂Vue底层的话，设计模式的思想是必不可少的。这就从简单的单例模式开始，学习学习设计模式 什么是单例模式字面上来看，就是只有一个实例的模式。简单来说，单例模式就是在整个系统中，保持一个实例，不生成新实例的模式。当然并不是说仅仅只能new一个对象出来，而是说，针对某个特殊的对象，我们在第一次将它实例化后，以后再次访问时，访问到的一直都是之前实例化好的特殊对象。 为什么需要单例模式正如上面说的那样，单例模式针对的是某些特殊的对象，那么该对象为什么被针对呢？ 需要单例模式实现的对象或系统，一般具有如下特点： 对象 需要频繁的被创建、销毁，但在这些过程中无法优化 需要比较多的资源：读取配置、产生其他依赖对象 环境 希望节省内存 希望节省系统性能的开销 希望某些资源不被多重占用 希望有一个能够统一处理资源和优化的对象 Vuex和Spring中的Bean对象就是如此 通过单例模式，我们能够简单的实现节省性能开销、节省内存、统一管理资源等功能。因为只有一个实例对象存在，并不会新生成。 如何实现单例模式单例模式的实现要点 保证对象只有一个，不能生成新对象出来 JavaScript实现的条件还是不变，保证对象只有一个，不能生成新对象出来。在JavaScript中，如果要实现私有化，首先想到的就是闭包了，闭包还能够使该实例不消失。其次结合if判断语句，如果实例存在，直接返回，不存在就执行new运算符初始化实例。 闭包实现1234567891011121314151617let SingleCase = (function Singleton (){ let instance = null function _init(){ // 此处可以定义一些初始化配置 } return function(){ console.log(instance) if(!instance){ instance = new _init() } return instance }})()var a = SingleCase()var b = SingleCase()a === b // true 其实js中window顶层对象就是个单例了。 Es6 Class实现首先我们要明白，Class是一个语法糖，本质上也是一个构造函数。回顾单例的要求，一是共享一个实例，二是不能生成新实例出来 构造函数 constructorClass有一个特点，在我们实例化Class时，会自动执行其内的constructor函数（每一个Class都有该函数，不声明默认为空。），可以初始化一些配置。 12345678910111213class Singleton{ constructor() { if(!Singleton.instance) { // 进行一些初始化操作 this.name = '张三' Singleton.instance = this } return Singleton.instance } }var a = new Singleton()var b = new Singleton()a === b // true 上面的方法能够实现单例的要点在于，只有第一个new Singleton()是真真的new出来的，之后的其实都是第一个new出来的实例对象。通过以下输出可以证明 12345678910111213class Singleton { constructor() { if(!Singleton.instance) { // 判断有无实例存在，若无则返回当前实例 window.first = this // 存储第一个实例 Singleton.instance = this // 将第一个实例赋值给Singleton.instance } window.second = this // 记录最新创建的实例 return Singleton.instance // 返回第一个实例 } }var a = new Singleton()var b = new Singleton()window.first === window.second // false 之所以该实例能够一直存在，是因为不仅仅后续创建的变量在引用它，而且Singleton本身的属性instance也在引用它，所以不会被销毁 静态方法/属性在Es6中，Class提供了静态方法。表示该方法为该类独有，不会被实例继承。我们可以通过静态方法来实现单例 12345678910// 静态方法class Singleton{ static getInstance() { if (!Singleton.instance) { Singleton.instance = new Singleton() } return Singleton.instance }}Singleton.getInstance() === Singleton.getInstance() // true 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性 1234567// 静态属性(不是很确定这么用行不行，但是也能实现)class Singleton { static SingleCase = {};}var a = Singleton.SingleCasevar b = Singleton.SingleCasea === b // true Vuex的实现思路by——Controllerszzy 123456789101112131415161718192021222324class SingleState { // 状态存储机制 data={} // 获取对象 get(key){ return this.data[key]||'' } // 存储对象 set(key,value){ return this.data[key]=value } // 外部调用此函数实例化 static getInstance() { if (!SingleState.instance) { SingleState.instance = new SingleState } return SingleState.instance }}const state_1 = SingleState.getInstance()state_1.set('hi','hello') // 设置 key = hi value = helloconst state_2 = SingleState.getInstance()console.log(state_2.get('hi')) // hello 使用过程中通过 Vue.use(Vuex) 安装了Vuex插件,而Vuex 插件是一个对象，它在内部实现了一个 install 方法，这个方法会在插件安装时被调用，从而把 Store 注入到Vue实例里去。也就是说每 install 一次，都会尝试给 Vue 实例注入一个 Store。 单例模式的优劣总结优点 减少了内存开支 减少了系统的性能开销 避免对资源的多重占用 设置全局的访问点， 优化和共享资源访问 缺点 扩展很困难 对测试是不利的 与单一职责原则有冲突 一个类应该只实现一个逻辑， 而不关心它是否是单例的， 是不是要单例取决于环境， 单例模式把“要单例”和业务逻辑融合在一个类中 对ES6中新增类型Symbol的疑问Symbol的实现或者用法和单例有什么联系呢？感觉上挺像的，虽然只是用于防止命名冲突。Es6一直不太会用出来，所以理解的也不是很到位。 总结其实单例模式还区分饿汉和懒汉两种模式，其差别在于：饿汉要求直接生成实例，不管有没有调用该对象懒汉要求什么时候用到了，什么时候再生成这个实例对象 补充学习了js一段时间后，发现之前js实现的单例是比较局限的，自己并没有从一个前端的角度去思考设计模式如何实现。所以在阅读了《JavaScript设计模式与开发实践》后，来补充下最新的理解。 上述闭包实现的单例存在着一些问题 单例的判断逻辑和单例对象的创建混杂在了一起。假如想去创建其他非单例对象时，需要重新在再写一部分相同的创建逻辑，所以，我们需要把二者拆分开，以实现 单一职责原则 12345678910111213141516171819// 单例逻辑的控制const getSingle = (fn)=&gt; { let result; return function(){ return result || (result = fn.call(result,arguments)); }}// 可复用的创建各种各样东西的方法const createObj = ()=&gt; {discribe:'创建对象的方法'};const createDiv = ()=&gt; {discribe:'创建Div的方法'};// 通过高阶函数，这样就准备好了创建单例的方法const createSingleObj = getSingle(createObj);const createSingleDiv = getSingle(createDiv );const a = createSingleObj();const b = createSingleObj();console.log(a === b) // true","link":"/2022/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"跨域常见的解决方法","text":"之前有被人问到过跨域这块的东西，当时答得有点模糊，再回顾一下 > 跨域概念浏览器中有一个安全策略叫同源策略，意思是协议、主机、端口必须相同，如果其一不同，则称之为跨域，对于跨域的请求，出于安全考虑，浏览器会对其访问进行一些限制 Ajax对于传统ajax，浏览器默认不允许其发送跨域请求，但是有三种方案可以解决 代理 代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域比较常见的是通过webpack集成的 devServer 实现代理去解决跨域问题 1234567891011// vue 的开发服务器代理配置// vue.config.jsmodule.exports = { devServer: { // 配置开发服务器 proxy: { // 配置代理 &quot;/api&quot;: { // 若请求路径以 /api 开头 target: &quot;http://dev.taobao.com&quot;, // 将其转发到 http://dev.taobao.com }, }, },}; JSONP 通过前后端配合，利用 script 标签不受同源策略限制去令服务端响应一段JS代码，将需要返回的数据作为参数传入该代码中，客户端再负责调用，类似ajax的回调函数。 但JSONP有一个明显的问题就是只能发送Get请求 CORS CORS是基于http1.1的一种跨域解决方案。全称叫跨域资源共享总体思路是：如果浏览器要跨域访问服务器的资源，需要获得服务器的允许针对不同的请求，CORS 规定了三种不同的交互模式，分别是：简单请求、需要预检的请求、附带身份凭证的请求。 当请求方法属于get、post、head；请求头仅包含安全的字段；请求头如果包含Content-Type，仅限 text/plain、multipart/form-data、application/x-www-form-urlencoded；同时满足上面三个条件后则判断为简单请求。 常见的安全字段如下： Accept Accept-Language Content-Language Content-Type DPR Downlink Save-Data Viewport-Width Width 当浏览器判断某个请求为简单请求后，会在请求头中自动添加 Origin 字段，用以告诉服务器，是哪个源地址在跨域请求，服务器在收到请求后，需要添加 Access-Control-Allow-Origin 用以表示开放的权限（* 表示允许所有，也可以写具体的地址表示只允许该源下的请求访问） 对于需要预检的请求（不符合上述条件），浏览器会先发送预检请求，如果服务器允许访问，则浏览器发送真实请求，最后服务器完成真实请求的响应 预检请求有以下特征： 请求方法为OPTIONS 没有请求体 请求头中包含 Origin：请求的源，和简单请求的含义一致 Access-Control-Request-Method：后续的真实请求将使用的请求方法 Access-Control-Request-Headers：后续的真实请求会改动的请求头 对于预检请求的响应，不需要请求体，只需要在响应头中添加 Access-Control-Allow-Origin：和简单请求一样，表示允许的源 Access-Control-Allow-Methods：表示允许的后续真实的请求方法 Access-Control-Allow-Headers：表示允许改动的请求头 Access-Control-Max-Age：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了 默认情况下，ajax 的跨域请求并不会附带 cookie，这样一来，某些需要权限的操作就无法进行，不过可以通过简单的配置就可以实现附带 cookie，xhr通过 withCredentials = true 配置，fetch 通过 init 参数对象中的 credentials配置。这样一来该请求就是一个附带身份凭证的请求，会在请求头中添加 cookie 字段。服务器需要在响应头中添加 Access-Control-Allow-Credentials: true即可 **对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为***。 参考文章：Http跨域资源共享 MDN前端面试必会网络之跨域问题解决","link":"/2022/10/31/%E8%B7%A8%E5%9F%9F/"}],"tags":[{"name":"Echarts","slug":"Echarts","link":"/tags/Echarts/"},{"name":"Api","slug":"Api","link":"/tags/Api/"},{"name":"懒加载","slug":"懒加载","link":"/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"垃圾回收","slug":"垃圾回收","link":"/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"ts","slug":"ts","link":"/tags/ts/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Hbuilder","slug":"Hbuilder","link":"/tags/Hbuilder/"},{"name":"状态模式","slug":"状态模式","link":"/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"name":"国际化","slug":"国际化","link":"/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"},{"name":"i18n","slug":"i18n","link":"/tags/i18n/"},{"name":"事件循环","slug":"事件循环","link":"/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"微任务","slug":"微任务","link":"/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","link":"/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"},{"name":"业务场景","slug":"业务场景","link":"/tags/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/"},{"name":"单例模式","slug":"单例模式","link":"/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"跨域","slug":"跨域","link":"/tags/%E8%B7%A8%E5%9F%9F/"}],"categories":[{"name":"问题解决方案","slug":"问题解决方案","link":"/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"TypeScript","slug":"前端/TypeScript","link":"/categories/%E5%89%8D%E7%AB%AF/TypeScript/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"事件循环","slug":"前端/事件循环","link":"/categories/%E5%89%8D%E7%AB%AF/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"业务场景","slug":"业务场景","link":"/categories/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/"},{"name":"个性化","slug":"hexo/个性化","link":"/categories/hexo/%E4%B8%AA%E6%80%A7%E5%8C%96/"}],"pages":[]}