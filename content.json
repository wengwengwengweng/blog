{"posts":[{"title":"Echarts动态获取数据颜色丢失的问题","text":"问题描述：使用Echarts饼图从后台请求数据时，请求成功后图表颜色丢失，变成纯黑色了。 问题原因：12345678visualMap: { show: false, min: 0,// 数据最小值的颜色明暗度 max: 600,// 数据最大值的颜色明暗度 inRange: { colorLightness: [0,1] // 表示颜色的明暗程度 } }, 出现纯黑的情况是因为数据太小了，而max中设置的又太高，导致了只能以最暗的情况展示所有数据。 解决思路：一 、将max调小点。二、将数据做处理计算出各组数据的值在总量的比重后作为数组放在data内部，min和max设为0,1。这样就能根据比重显示明暗度了。 当然，也可以在后端返回数据的时候将value直接返回为比重也行。或者说多返回一个总量，前端自行处理也阔以。","link":"/2022/09/02/Echarts%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E9%A2%9C%E8%89%B2%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"Echarts常见问题整理","text":"前言本次项目中负责了一个使用Echarts做的页面，涉及的图表类型有 柱状图(横竖两种)、折线图、气泡图、漏斗图、饼图期间也遇到了不少问题，但是大部分的问题都是可以通过Echarts官方文档上找到解决办法的。下面记录一下问题及解决办法和Echarts的一些学习、码字心得。 一、常见问题记录1.如何创建一个自适应的Echarts图表（动态给Echarts图表当前高度初始化+窗口缩放Echarts图表自适应）讲道理这个问题一开始着实困扰我了大半天，因为页面需要自适应，根本不知道图表一开始具体的 Height 是多少。而且此次布局使用的是Flex布局，分左中右三块，每块上下各有一个图表，加一起是六个。这里有两种解决思路，各有优缺点吧，这次用的第二个。 提供的思路并非最优解，只是在解决本次项目的过程中效果比较好，如果有什么更好的想法欢迎指出 动态高度初始化思路一：通过css样式aspect-ratio（宽高比）解决因为采用的是Flex布局，而且是左中右三块，左右25%，中间50%，因此宽度是一定有的 此时，给图表的容器加上一个宽高比aspect-ratio，高度设置为100%，图表在初始化的时候就能根据宽高比初始化出来。 优点： 操作简单，css直接加就ok 对于宽高比确定的图表完美契合 图表不会变形 缺点 分配的宽度过大的话会影响整体布局（超出盒子范围） 不适合难以确定宽高比 或 图表不要求定型 的情况没办法使用 思路二：通过在父组件dom操作获取当前高度clientHeight（只读），作为参数调用子组件方法，在子组件获取到当前高度后初始化。优点 布局不会乱 适合难以确定宽高比 或 图表不要求定型 的情况 缺点 这样写的高度是定死的，除非再次传参初始化，否则在不同大小的显示器上就只有刷新后才能正常自适应。 代码实现父组件：关键代码 12345&lt;Histogram ref=&quot;echarts1&quot; /&gt;// 有五个类似的组件for (var i = 1; i &lt;= 5; i++) { this.$refs['echarts'+i].setHeight(document.getElementsByClassName('side-echarts-container')[0].clientHeight)} 子组件：关键代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;template&gt; &lt;div&gt; &lt;div id=&quot;hstogram&quot; class=&quot;charts&quot; :style=&quot;{'height':sideEchartsContainerHeight+'px','width':' 100%'}&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as echarts from 'echarts'import { getBarGraphData } from '../../api/dataStatistics.js'var option = { // color: ['rgb(245,33,45)', 'rgb(255,229,143)', 'rgb(11,115,255)'], color: [new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, color: '#f00' }, { offset: 0, color: '#f99' }]), new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, color: 'rgb(249, 173, 21)' }, { offset: 0, color: 'rgb(255,255,153)' }]), new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, color: 'rgb(11,115,255)' }, { offset: 0, color: 'rgba(0,255,255)' }]) ], legend: { textStyle: { color: 'white' }, top: 25 }, grid: { show: true, borderColor: 'rgba(255, 255, 255,0.5)' }, tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } }, xAxis: { type: 'category', axisLabel: { interval: 0, // 显示全部x坐标 // rotate: 35, color: 'rgba(255, 255, 255,1)' }, nameTextStyle: { align: 'center' }, splitLine: { show: true, lineStyle: { color: 'rgba(255, 255, 255,0.5)', width: 1, type: 'dashed' } } }, yAxis: { axisLabel: { color: 'rgba(255, 255, 255,1)' }, splitLine: { lineStyle: { color: 'rgba(255, 255, 255,0.5)', width: 1, type: 'dashed' } } }, series: [ { type: 'bar', barWidth: 10, itemStyle: { //柱形图圆角，鼠标移上去效果，如果只是一个数字则说明四个参数全部设置为那么多 normal: { //柱形图圆角，初始化效果 barBorderRadius:[15, 15, 0, 0] } } }, { type: 'bar', barWidth: 10, itemStyle: { //柱形图圆角，鼠标移上去效果，如果只是一个数字则说明四个参数全部设置为那么多 normal: { //柱形图圆角，初始化效果 barBorderRadius:[15, 15, 0, 0] } } }, { type: 'bar', barWidth: 10, itemStyle: { //柱形图圆角，鼠标移上去效果，如果只是一个数字则说明四个参数全部设置为那么多 normal: { //柱形图圆角，初始化效果 barBorderRadius:[15, 15, 0, 0] } } }, ]}export default { name: 'Histogram', data() { return { charsData: [], // 之后通过请求放数据，需要效果的可以先加进去看看 sideEchartsContainerHeight: 0 } }, methods: { setHeight(height){ this.sideEchartsContainerHeight = height this.getData() // 请求默认数据(无参数) this.$nextTick(function() { this.echartsInit() // 初始化echarts }) }, echartsInit() { myEcharts = echarts.init(document.getElementById('hstogram')) // 获取图表节点 myEcharts.setOption(option) } }}&lt;/script&gt; 窗口缩放时图表内容自适应其实图表本身是通过canvas这个容器画出来的，canvas在画完后想要让内容自适应只有重绘了。好在Echarts官方提供了这个函数resize() 123456789// 监听实现window.addEventListener('resize', function() { // bubbleChart 是图表的实例 echartsInstance（调用过init函数后） bubbleChart.resize()})// 手动调用chartsResize(){ bubbleChart.resize()} 通过全局设置监听，实现在窗口缩放时图表的重绘，当然这个监听对象加给谁都行，但是要记得销毁。 本次项目中将每个图表都搞成了一个组件（维护起来比较方便），然后在组件里面写的监听。其实感觉正确的写法应该是在父组件加监听，调6个子组件的resize()方法的，但是项目比较急，就没维护这块。 2.调整Echarts图表大小、位置、显示网格线通过在option中设置grid的四个值即可： 123456789option = { grid: { show:true, // 显示网格线 top:10, left:10， // bottom:10, // right:10 }} grid设置两个值即可确定图表的大小和位置。值可以是像 20 这样的具体像素值，可以是像 '20%' 这样相对于容器高宽的百分比，也可以是 'left', 'center', 'right'。如果 left 的值为'left', 'center', 'right'，组件会根据相应的位置自动对齐。 值得一提的是，grid中containLabel如果为true的话，grid决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置,常用于防止标签溢出的场景。为false，则只算由图标形成的区域。 网格的背景只有在设置show:true时才会起作用，默认为透明 3.柱状图根据x坐标数量动态判断柱状图柱条的宽度、防止x坐标过多导致重叠本次在写项目时，由于存在检索范围这一条件，导致x坐标的个数有时候很密集，有时候有很稀疏，所以就有了要根据x坐标的个数来动态改变柱状图柱子的宽度，来保证图表不会引起误解（1月份的柱子太宽占到了2月份的坐标）。 宽度问题图表的样式修改一般在series内的itemStyle里面，我们可以通过barwidth来修改柱状图柱条的宽度。 动态改变宽度的前提条件是我们需要知道数据量，也就是请求成功后的返回值。 12345678910111213141516// getBarGraphData 发出请求，.then表示请求成功后的回调函数，res为请求的返回值getBarGraphData().then(res =&gt; { let baseLength = 10 let resLength = 40 / res.data.length // 此处应该是 (图表宽度 / {请求返回的数据条数 * 每个x坐标展示的柱条个数})。结果可以稍微小点，便于更好的去展示。这里只是演示用，先写死了。 myEcharts.setOption({ series: [ { type: 'bar', barWidth: Math.min(baseLength, resLength) }, { type: 'bar', barWidth: Math.min(baseLength, resLength) }, { type: 'bar', barWidth: Math.min(baseLength, resLength) } ], dataset: { dimensions: ['product', '红', '黄', '蓝'], source: that.charsData } }) }) 初始化时可以不给数据，只写配置。在请求成功后通过setOption更新配置即可。 防止x坐标过多导致重叠两种解决办法 通过旋转一定的x坐标角度实现不重叠 123456789option = { xAxis: { axisLabel: { //interval: 0, // 显示全部x坐标 rotate: 35, color: 'rgba(255, 255, 255,1)' }, }} 显示部分x坐标，隔几个个x坐标显示一个（间隔的x坐标数目固定） 123456789option = { xAxis: { axisLabel: { interval: 1, // 是否显示全部x坐标 // rotate: 35, color: 'rgba(255, 255, 255,1)' }, }} 4.Echarts实现渐变色及更新数据后渐变消失的问题如果我们不给图表设置颜色，图表会默认从['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc']中挑选颜色。但是单纯设置颜色有时候丑的一批，所以加上渐变效果会好很多 线性渐变不知道为什么官方文档上没搜到，Echarts内部是带有一个渐变色生成器的 更多关于echarts.graphic的细节请参阅 就是不知道为啥，官方文档上没给出来这个东西。但其实是可以直接使用的，比如我希望柱状图的填充为渐变填充，我就可以这么写 1234567891011121314151617181920212223option = { color: [ // 第一个柱状图的颜色填充，参数依次对应 右/下/左/上 四个位置，1表示渐变色从正上方开始 // 第5个参数则是一个数组 用于配置颜色的渐变过程. 包含offset和color两个参数. offset的范围是0 ~ 1, 用于表示位置, color表示颜色 new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, // 100%处的颜色 color: '#f00' }, { offset: 0, // 0%处的颜色 color: '#f99' }]), // 第二个柱状图的颜色填充 new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, // 100%处的颜色 color: 'rgb(249, 173, 21)' }, { offset: 0, // 0%处的颜色 color: 'rgb(255,255,153)' }]) // ... 以此类推 ]} 然后官方上貌似是直接把这个new出来的对象搞成配置项了，下面是官方的写法： 12345678910111213141516171819202122option = { series:[{ color: { type: 'linear', x: 0, // 渐变起始位置横坐标。 y: 0, // 渐变起始位置纵坐标。 x2: 0, // 渐变终止位置横坐标。 y2: 1, // 渐变终止位置纵坐标。 // 组成渐变色的颜色。每个颜色包括 offset 与 color 属性， // 前者表示渐变位置（类型：number），后者表示具体的颜色（类型：string） colorStops: [{ offset: 0, color: 'red' // 0% 处的颜色 }, { offset: 1, color: 'blue' // 100% 处的颜色 }], // 如果为 false，则 colorStops 取值范围是 0 到 1； // 如果为 true，则 x、 y、 x2、 y2、 colorStops 的坐标和元素是一致的 // （也就是说，原先用 1 表示物体最右侧，这时需要用元素实际宽度表示最右侧）。 global: false // 缺省为 false } }]} 不是很清楚哪个好点，但是感觉上应该是直接配置会好点，而不是 new 调用。 径向渐变new渐变色 12345678910111213141516171819202122option = { color: [ // 第一个柱状图的颜色填充，参数依次对应 渐变中心位置横坐标/渐变中心位置纵坐标/渐变半径，默认值为0.5 // 第5个参数则是一个数组 用于配置颜色的渐变过程. 包含offset和color两个参数. offset的范围是0 ~ 1, 用于表示位置, color表示颜色 new echarts.graphic.RadialGradient(0.5, 0.5, 0.5, [{ // ！！！！ 此处是RadialGradient 而不是 LinearGradient offset: 1, // 100%处的颜色 color: '#f00' }, { offset: 0, // 0%处的颜色 color: '#f99' }]), // 第二个柱状图的颜色填充 new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 1, // 100%处的颜色 color: 'rgb(249, 173, 21)' }, { offset: 0, // 0%处的颜色 color: 'rgb(255,255,153)' }]) // ... 以此类推 ]} 官方文档写法 123456789101112131415161718192021option = { series:[{ color: { type: 'radial', // ！！！！！ 变成了radial x: 0.5, y: 0.5, r: 0.5, // 组成渐变色的颜色。每个颜色包括 offset 与 color 属性， // 前者表示渐变位置（类型：number），后者表示具体的颜色（类型：string） colorStops: [{ offset: 0, color: 'red' // 0% 处的颜色 }, { offset: 1, color: 'blue' // 100% 处的颜色 }], // 如果为 false，则 colorStops 取值范围是 0 到 1； // 如果为 true，则 x、 y、 x2、 y2、 colorStops 的坐标和元素是一致的 // （也就是说，原先用 1 表示物体最右侧，这时需要用元素实际宽度表示最右侧）。 global: false // 缺省为 false } }]} 重置数据渐变消失的问题本次项目中因为需要隔一段时间执行一遍动画（科技感，要动态），所以就写了个计时器清空数据再放进去。 123456789101112timer2 = setInterval(function () { myEcharts.setOption({ // 展示/更新 数据 series:[ { data: [] } ] }) myEcharts.setOption({ // 展示/更新 数据 series:[ { data: that.charsData } ] })}, 6000) 上面这样写在其他图（柱状、饼、漏斗、气泡）里面都是可以正常出来重新加载的过度动画的。但是到了折线图里却没了反应。折线图只有在第一次执行setOption时才有过度动画，之后就没有了，思来想去没想出来啥问题。就避开了这个问题 这里使用了myEcharts.clear()方法清除了当前实例里面的内容(不是销毁)，之后通过重新setOption来放入配置和数据实现动画加载。 然后问题来了，重新加载的图表走的是默认颜色！即使在新的配置里面写渐变色也还是没有起作用人直接傻了，想不通为啥。 解决办法看了看官方文档，发现setOption接收的不止一个参数，他有一个notMerge这个参数，表示了是否不跟之前设置的 option 进行合并。默认为 false。改成true后解决了这个问题。 具体原因还是没搞明白。按理说默认合并也会和数据一样覆盖之前的数据啊，猜测是因为没有用官方写的渐变而是用了new实现，有待测试。 5.Echarts中data和dataset的含义、Echarts数据返回格式Echarts中data和dataset的含义乍一看下data和dataSet好像没什么区别，只是一个需要切割数据到每个series里，一个可以统一使用。但其实在一些特殊情况下，是不支持使用dataSet的。 举个例子：使用 dataset 同时使用 appendData，只支持系列使用自己的 series.data 时使用 appendData。 Data没什么好说的，给那个系列哪个系列就用这组数据。 优点是 直观易理解 适于对一些特殊图表类型进行一定的数据类型定制。 缺点是 为匹配这种数据输入形式，常需要有数据处理的过程,分割到不同系列 此外，不利于多个系列共享一份数据，也不利于基于原始数据进行图表类型、系列的映射安排。 dataset相对于data来说，最直观的就是我们不需要做分割数据的处理。 优点是 能够贴近这样的数据可视化常见思维方式：(I) 提供数据，(II) 指定数据到视觉的映射，从而形成图表。 数据和其他配置可以被分离开来。数据常变，其他配置常不变。分开易于分别管理。 数据可以被多个系列或者组件复用，对于大数据量的场景，不必为每个系列创建一份数据。 支持更多的数据的常用格式，例如二维数组、对象数组等，一定程度上避免使用者为了数据格式而进行转换。 缺点是 可能需要对dataset进行映射，要理解维度和映射的意思。 在部分场景下不适用，比如上面的例子。 根据之前的学习来看，应该是在数据量特别大的时候会用到一些特定的方法，在使用这些方法时不支持与dataset一起使用。假如我们数据量不是很大的情况下，还是dataset会方便好用一点 Echarts数据返回格式data就不用说了吧，主要说下dataset dataset常见的数据格式有下面两种 12345678910111213141516171819202122dataset: { // 提供一份数据。 source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 43.3, 85.8, 93.7], ['Milk Tea', 83.1, 73.4, 55.1], ['Cheese Cocoa', 86.4, 65.2, 82.5], ['Walnut Brownie', 72.4, 53.9, 39.1] ]}dataset: { // 用 dimensions 指定了维度的顺序。直角坐标系中， // 默认把第一个维度映射到 X 轴上，第二个维度映射到 Y 轴上。 // 如果不指定 dimensions，也可以通过指定 series.encode完成映射 dimensions: ['product', '2015', '2016', '2017'], source: [ {product: 'Matcha Latte', '2015': 43.3, '2016': 85.8, '2017': 93.7}, {product: 'Milk Tea', '2015': 83.1, '2016': 73.4, '2017': 55.1}, {product: 'Cheese Cocoa', '2015': 86.4, '2016': 65.2, '2017': 82.5}, {product: 'Walnut Brownie', '2015': 72.4, '2016': 53.9, '2017': 39.1} ] }, 维度和映射维度显然，相对于第一种来说，第二种可读性更高一点。但是第一种的灵活性更高。 我们可以把维度理解为横纵两个方向（不考虑3d图，这个没了解呢哈哈）。 通过一定的配置，我们能够 将横向维度的数据映射到x轴上，纵向的数据叫做横向维度的数据项 将纵向维度的数据映射到x轴上，横向的数据叫做纵向维度的数据项 用第一个例子来帮助理解下： 12345678910111213141516dataset: { // 提供一份数据。 // 横向维度就是每一行，纵向维度就是每一列。 // 在此种数据格式下，我们可以轻松地理解维度的含义。 // 我们可以将这份数据看做一个坐标系，第一列和第一行可以是xy轴(任意) // 后面的数据对应的是x轴和y轴所对应的值 // 比如我把Matcha Latte当为x轴，那么43.3的意义是Matcha Latte在2015年的值 // 或者我把2015当为x轴，那么43.3的意义是在2015年Matcha Latte的值 source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 43.3, 85.8, 93.7], ['Milk Tea', 83.1, 73.4, 55.1], ['Cheese Cocoa', 86.4, 65.2, 82.5], ['Walnut Brownie', 72.4, 53.9, 39.1] ]} 要实现上述更改xy轴的效果，可以使用 seriesLayoutBy 配置项，改变图表对于行列的理解。seriesLayoutBy 可取值： 'column': 默认值。系列被安放到 dataset 的列上面。 'row': 系列被安放到 dataset 的行上面。12345678910111213141516171819202122232425262728293031323334option = { dataset:[ source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 43.3, 85.8, 93.7], ['Milk Tea', 83.1, 73.4, 55.1], ['Cheese Cocoa', 86.4, 65.2, 82.5], ['Walnut Brownie', 72.4, 53.9, 39.1] ] ], xAxis: [ {type: 'category', gridIndex: 0}, {type: 'category', gridIndex: 1} ], yAxis: [ {gridIndex: 0}, {gridIndex: 1} ], grid: [ {bottom: '55%'}, {top: '55%'} ], series: [ // 这几个系列会在第一个直角坐标系中，每个系列对应到 dataset 的每一行。 {type: 'bar', seriesLayoutBy: 'row'}, {type: 'bar', seriesLayoutBy: 'row'}, {type: 'bar', seriesLayoutBy: 'row'}, // 这几个系列会在第二个直角坐标系中，每个系列对应到 dataset 的每一列。 {type: 'bar', xAxisIndex: 1, yAxisIndex: 1}, {type: 'bar', xAxisIndex: 1, yAxisIndex: 1}, {type: 'bar', xAxisIndex: 1, yAxisIndex: 1}, {type: 'bar', xAxisIndex: 1, yAxisIndex: 1} ]} 映射一般通过series.encode来配置映射，效果和上面说的差不多，但是能够指定某列去映射，写个例子大家去官网上瞅瞅吧 1234567891011121314151617181920212223242526272829 var option = { dataset: { source: [ ['score', 'amount', 'product'], [89.3, 58212, 'Matcha Latte'], [57.1, 78254, 'Milk Tea'], [74.4, 41032, 'Cheese Cocoa'], [50.1, 12755, 'Cheese Brownie'], [89.7, 20145, 'Matcha Cocoa'], [68.1, 79146, 'Tea'], [19.6, 91852, 'Orange Juice'], [10.6, 101852, 'Lemon Juice'], [32.7, 20112, 'Walnut Brownie'] ] }, xAxis: {}, yAxis: {type: 'category'}, series: [ { type: 'bar', encode: { // 将 &quot;amount&quot; 列映射到 X 轴。 x: 'amount', // 将 &quot;product&quot; 列映射到 Y 轴。 y: 'product' } } ]};","link":"/2022/09/02/Echarts%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"},{"title":"Api IntersectionObserver","text":"IntersectionObserverIntersectionObserver API 是用来监视某个元素是否滚动进了浏览器窗口的可视区域（视口）或者滚动进了它的某个祖先元素的可视区域内。它的主要功能是用来实现延迟加载和展现量统计。 ![img](02 IntersectionObserver.assets/116671-20160605131111086-768036414.png) 它提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root) 构造函数1new IntersectionObserver(callback, options) callback 是个必选参数，当有相交发生时，浏览器便会调用它，后面会详细介绍； options 整个参数对象以及它的三个属性都是可选的： root 根元素，它有很多后代元素，想要做的就是判断它的某个后代元素是否滚动进了自己的可视区域范围。这个 root 参数就是用来指定根元素的，默认值是 null。即浏览器窗口。 需要注意的一点是，如果 root 不是 null，那么相交区域就不一定在视口内了，因为 root 和 target 的相交也可能发生在视口下方 threshold 当目标元素和根元素相交时，用相交的面积除以目标元素的面积会得到一个 0 到 1（0% 到 100%）的数值 ![img](02 IntersectionObserver.assets/116671-20160608175232261-11872166.png) IntersectionObserver API 的基本工作原理就是：当目标元素和根元素相交的面积占目标元素面积的百分比到达或跨过某些指定的临界值时就会触发回调函数。threshold 参数就是用来指定那个临界值的，默认值是 0，表示俩元素刚刚挨上就触发回调。有效的临界值可以是在 0 到 1 闭区间内的任意数值，比如 0.5 表示当相交面积占目标元素面积的一半时触发回调。而且可以指定多个临界值，用数组形式，比如 [0, 0.5, 1]，表示在两个矩形开始相交，相交一半，完全相交这三个时刻都要触发一次回调函数。如果你传了个空数组，它会给你自动插入 0，变成 [0]，也等效于默认值 0。 rootMagin 可以给根元素添加一个假想的 margin，从而对真实的根元素区域进行缩放。比如当 root 为 null 时设置 rootMargin: “100px”，实际的根元素矩形四条边都会被放大 100px ![img](02 IntersectionObserver.assets/116671-20160606131900605-2121804167.png) 实例方法observe()观察某个目标元素，一个观察者实例可以观察任意多个目标元素。注意，这不是事件，没有冒泡。 unobserve()取消对某个目标元素的观察，延迟加载通常都是一次性的，observe 的回调里应该直接调用 unobserve() 那个元素. disconnect()取消观察所有已观察的目标元素 takeRecords() 使用案例很少，不过多说明 理解这个方法需要讲点底层的东西：在浏览器内部，当一个观察者实例在某一时刻观察到了若干个相交动作时，它不会立即执行回调，它会调用 window.requestIdleCallback() （目前只有 Chrome 支持）来异步的执行我们指定的回调函数，而且还规定了最大的延迟时间是 100 毫秒，相当于浏览器会执行 回调函数回调函数共有两个参数，第二个参数就是观察者实例本身，一般没用，因为实例通常我们已经赋值给一个变量了，而且回调函数里的 this 也是那个实例。 第一个参数是个包含有若干个 IntersectionObserverEntry 对象的数组。每个 IntersectionObserverEntry 对象都代表一次相交，它的属性们就包含了那次相交的各种信息。entries 数组中 IntersectionObserverEntry 对象的排列顺序是按照它所属的目标元素当初被 observe() 的顺序排列的。 entries 数组中的实例有如下属性 time 相交发生时距离页面打开时的毫秒数（有小数），也就是相交发生时 performance.now() 的返回值，比如 60000.560000000005，表示是在页面打开后大概 1 分钟发生的相交。在回调函数里用 performance.now() 减去这个值，就能算出回调函数被 requestIdleCallback 延迟了多少毫秒： 1234567&lt;script&gt; let observer = new IntersectionObserver(([entry]) =&gt; { document.body.textContent += `相交发生在 ${performance.now() - entry.time} 毫秒前` }) observer.observe(document.documentElement)&lt;/script&gt; target 相交发生时的目标元素，因为一个根元素可以观察多个目标元素，所以这个 target 不一定是哪个元素 rootBounds 一个对象值，表示发生相交时根元素可见区域的矩形信息，像这样 12345678{ &quot;top&quot;: 0, &quot;bottom&quot;: 600, &quot;left&quot;: 0, &quot;right&quot;: 1280, &quot;width&quot;: 1280, &quot;height&quot;: 600} boundingClientRect 发生相交时目标元素的矩形信息，等价于 target.getBoundingClientRect() intersectionRect 根元素和目标元素相交区域的矩形信息。 intersectionRatio 0 到 1 的数值，表示相交区域占目标元素区域的百分比，也就是 intersectionRect 的面积除以 boundingClientRect 的面积得到的值 实用场景惰性加载（lazy load）123456789101112131415161718function query(selector) { return Array.from(document.querySelectorAll(selector));}var observer = new IntersectionObserver( function(changes) { changes.forEach(function(change) { var container = change.target; var content = container.querySelector('template').content; container.appendChild(content); observer.unobserve(container); }); });query('.lazy-loaded').forEach(function (item) { observer.observe(item);}); 无限滚动（infinite scroll）123456789101112var intersectionObserver = new IntersectionObserver( function (entries) { // 如果不可见，就返回 if (entries[0].intersectionRatio &lt;= 0) return; loadItems(10); console.log('Loaded new items'); });// 开始观察intersectionObserver.observe( document.querySelector('.scrollerFooter'));","link":"/2022/09/02/IntersectionObserverApi/"},{"title":"JavaScript垃圾回收机制","text":"前置知识堆栈栈什么是栈栈其实是一种数据结构，有着先进后出，后进先出的特性，用生活中的事物来理解最形象的就是汉诺塔了。我们在栈中存储的数据就像汉诺塔的盘子一样，最先放进去在最下面，最后放入的盘子在最上面。我们想拿数据的时候，也需要从塔顶开始拿，也就是最后放入的开始，上面的拿完才能拿下面的。 下图可以看做有三个栈 简而言之，我们可以将栈理解为一个具有先进后出，后进先出特点的存储空间，对于JavaScript来说，它会把基本数据类型放入栈内存储。 堆什么是堆当我们创建一个对象的时候，实际上会在堆空间开辟一个空间，我们声明的变量保存的其实是堆空间的地址简而言之，堆空间是存放复杂数据类型的存储空间，我们通过变量存储的其实是这些数据在堆空间内的地址。 当我们将一个本来存有地址的变量设置为null时，本质上是将该变量与堆空间的联系斩断，但堆空间内仍存有之前的复杂数据类型。只有当垃圾回收机制执行时，才会将这些没有人引用的复杂数据类型销毁，释放出堆空间。 执行上下文与作用域链执行上下文在JavaScript中有三种上下文 全局执行上下文：Global CodeJavaScript代码开始运行的默认环境 函数执行上下文：Function Code存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。 Eval 函数执行上下文： 使用eval()执行代码，因为很少用所以本次不做讨论。 在JavaScript代码执行的过程中，默认进入的总是全局执行上下文，JavaScript会把其存入上下文栈中去，每当遇到定义的函数被执行，便会创建一个新的执行上下文，并将其存入上下文栈中去。 当一个函数执行完毕后，上下文栈会将其弹出，将上下文环境交还给上个函数。 作用域链上下文栈会根据栈内的顺序形成一条作用域链，用来控制变量的访问。处于上层作用域链的函数内部无法访问下层作用域链的变量。 下层作用域链中的函数可以访问上层作用域链的对象，若上层也没有，则再向上查找，直到全局作用域也没有，则返回null。 一、JavaScript中怎么被定义为垃圾使用局部变量123456789function makeTrash(){ var a = 1;}// 在makeTrash执行时，会创建a这个变量。// 此时栈空间会为其分配一块区域供其存储。makeTrash();// 函数执行完后，由于不再需要变量a，所以此时的a便成为了垃圾// 栈空间将会释放之前为a分配的空间。// 至此，垃圾回收完毕 使用对象123456789// 此时的obj指向堆内存中创建的一块空间var obj = { name:'ZhangSan', age:'18'}obj = null// 当我们对其赋值为null的时候，obj与堆内存中的空间的关系被斩断。// 由于堆内存中的空间没有人引用，所以这块空间就成了JavaScript中所谓的的垃圾 概括凡是未被引用的变量或对象，都会被视为垃圾。 可能成为垃圾的特例全局变量由于全局对象window的销毁一般发生在页面卸载时，所以对于全局变量是否为垃圾很难进行判断，所以要尽量少用全局变量，或在用完设置为null。闭包在闭包中，由于返回的函数对于变量持有引用，垃圾回收机制也无法对外层函数中被引用的变量进行回收，所以需要手动把接收闭包返回值的对象设置为null。 二、两种回收策略JavaScript中垃圾回收机制的策略分为两种 标记清理 引用计数 标记清理当变量进入上下文时，会对其添加上 存在于上下文 的标记。当变量退出上下文时，对退出上下文的变量添加上退出上下文的标记 例如在一个函数中声明一个变量，该变量就会被标记为存在于上下文中。当函数执行完毕，上下文栈弹出该函数的上下文，其内变量添加 退出上下文的标记。 此种策略的垃圾回收机制在运行的时候，会对所有已存在于内存的变量进行标记。 之后垃圾回收机制会清除上下文中所有变量的标记，包括其引用的变量的标记也会在此被清除。 最后仍然被标记的变量，即为要回收的垃圾。因为没有地方引用他们。 引用计数该种策略会对每个值记录它被引用的次数。声明变量并给他赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，则引用次数+1。 类似的，如果保存对该值引用的变量被其他值给覆盖了，那么引用数-1。 当一个值的引用数为0时，就说明没有办法在访问到这个值了。此时被判断为垃圾，在下次垃圾回收机制执行时会释放引用值为0的值所占用的内存。 概括本质上都是找到未被引用的值，从而在垃圾回收执行时释放其空间。 三、什么时候执行垃圾回收不同浏览器的引擎执行垃圾回收的时机也不一样。 根据网上查阅的资料来看，对于大部分浏览器的引擎来说，我们无法人为的去控制什么时候进行垃圾回收，因为js并没有暴露出相关的接口供我们调用。 我们在MDN中可以看到一些相关的说明 不再需要内存时释放大多数内存管理问题发生在这个阶段。此阶段最困难的方面是确定何时不再需要分配的内存。 低级语言要求开发人员手动确定程序中哪个点不再需要分配的内存并释放它。 一些高级语言，例如 JavaScript，使用一种称为垃圾收集 (GC) 的自动内存管理形式。垃圾收集器的目的是监控内存分配并确定何时不再需要分配的内存块并回收它。这个自动过程是一个近似值，因为确定是否仍然需要特定内存的一般问题是不可判定的。 在拥有了两种垃圾回收策略后，执行的周期性不再是问题，因为我们能够将垃圾明确出来，只需要等下次回收即可。 周期不再是问题 123456789function f() {var x = {};var y = {};x.a = y; // x references yy.a = x; // y references xreturn 'azerty';&gt;}&gt;f(); 在上面的示例中，函数调用返回后，这两个对象不再被可从全局对象访问的任何资源引用。因此，垃圾收集器将发现它们无法访问并回收分配的内存。 关于Chrome V8引擎的GC分代回收绝大多数对象的生存期很短，只有某些对象的生存期较长。为利用这一特点，V8将堆进行了分区： 新生区：大多数对象被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立。 老生指针区：这里包含大多数可能存在指向其他对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里。 老生数据区：这里存放只包含原始数据的对象（这些对象没有指向其他对象的指针）。字符串、封箱的数字以及未封箱的双精度数字数组，在新生区存活一段时间后会被移动到这里。 大对象区：这里存放体积超越其他区大小的对象。每个对象有自己mmap产生的内存。垃圾回收器从不移动大对象。 代码区：代码对象，也就是包含JIT之后指令的对象，会被分配到这里。这是唯一拥有执行权限的内存区（不过如果代码对象因过大而放在大对象区，则该大对象所对应的内存也是可执行的。译注：但是大对象内存区本身不是可执行的内存区）。 Cell区、属性Cell区、Map区：这些区域存放Cell、属性Cell和Map，每个区域因为都是存放相同大小的元素，因此内存结构很简单。 回收的执行周期对象起初会被分配在新生区（通常很小，只有1-8 MB，具体根据行为来进行启发）。在新生区的内存分配非常容易：我们只需保有一个指向内存区的指针，不断根据新对象的大小对其进行递增即可。当该指针达到了新生区的末尾，就会有一次清理（小周期），清理掉新生区中不活跃的死对象。 对于活跃超过2个小周期的对象，则需将其移动至老生区。老生区在标记－清除或标记－紧缩（大周期）的过程中进行回收。大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。至于足够多到底是多少，则根据老生区自身的大小和程序的动向来定。 Scavenge算法V8采用了Scavenge算法，是按照Cheney的算法实现的。 算法的大致流程为：将新生区划分为**入区(from-space)和出区(to-space)**。绝大多是内存分配是在出区进行，而当出区被填满时，我们会交换出区和入区，然后将入区中活跃的对象复制至出区或老生区当中。在这时我们会对活跃对象进行紧缩，以便提升Cache的内存局部性，保持内存分配的简洁快速。上图描述了在新生区中，如何回收的垃圾b。 而当一个变量在两次从入区(from-space) 移动到 出区(to-space) 时。他就会被提升到老生区的内存空间中 注意，在上面的回收过程中，为了避免有老生区的变量指向新生区，但在新生区的清理周期中被引用的变量被错误回收，V8引擎做了额外的处理：写屏障 写屏障肯定不可能通过遍历老生区去查找到底哪个变量引用了新生区的变量，耗时太大。所以通过在写缓冲区中创建一个列表去记录所有老生区对象指向新生区的情况，这样就可以避免上述错误回收。该记录行为总是发生在写操作的时候，每个写操作都会经历这么一关。 老生区在老生区中，用到的是上文我们说过的标记清理法结合标记紧缩法去回收。 标记清理法是如何标记的V8 使用每个对象的两个 mark-bits 和一个标记工作表来实现标记。两个 mark-bits 编码三种颜色：白色（00），灰色（10）和黑色（11）。 如果一个对象的状态为白，那么它尚未被垃圾回收器发现，同时最开始所有对象都是白色如果一个对象的状态为灰，那么它已被垃圾回收器发现，但它的邻接对象仍未全部处理完毕如果一个对象的状态为黑，则它不仅被垃圾回收器发现，而且其所有邻接对象也都处理完毕 算法的核心实际是深度优先搜索，从根（Root）可达的对象会被染为灰色，并放入标记用的一个单独分配的双端队列。标记阶段的每次循环，GC会将一个对象从双端队列中取出，染为黑色，然后将它的邻居对象染为灰色，并把邻居对象放入双端队列。这一过程在双端队列为空且所有对象都变黑时结束。 特别大的对象，如长数组，可能会在处理时分片，以防溢出双端队列。如果双端队列溢出了，则对象仍然会被染为灰色，但不会再被放入队列（这样他们的邻接对象就没有机会再染色了）。因此当双端队列为空时，GC仍然需要扫描一次，确保所有的灰对象都成为了黑对象。对于未被染黑的灰对象，GC会将其再次放入队列，再度处理。 标记算法结束时，所有的活跃对象都被染为了黑色，而所有的死对象则仍是白的。 对于深度优先和广度优先可以看看算法图解，画的挺形象的。 标记紧缩法 在使用完标记清理法后，确实能够将垃圾清理掉，但是清理后的空间是不连续的。而一些数据的存储要求的是连续的空间，所以这时候就需要用标记紧缩法去整理碎片空间。 达到这种效果 增量标记法当一个堆很大而且有很多活跃对象时，标记-清除和标记-紧缩算法会执行的很慢，又因为垃圾回收机制在执行时会阻塞js代码(JS是单线程的)，所以在2012年年中，谷歌引入了增量标记和惰性清理两项技术。 增量标记允许堆的标记发生在几次5-10毫秒（移动设备）的小停顿中。增量标记在堆的大小达到一定的阈值时启用。启用后每当一定量的内存分配后，脚本就会停顿一次用来执行标记，同样是黑白灰三色，也同样是深度优先搜索。 写屏障和上文提到过的写屏障类似，为了避免出现黑色指向白色这种情况出现，我们通过写屏障记录黑色指向白色的指针，一旦发现这种指针，就会将黑色对象重新染色为灰色对象，重新放回到双端队列中。当算法将该对象取出时，其包含的指针会被重新扫描，这样活跃的白对象就不会漏掉。 惰性清理因为所有对象已被处理，因此非死即活。谁是垃圾已经很明确了，所以不用着急释放空间，延迟一下清理也可以。 效果类似下图所示 上面的是完整的GC执行，下方的是增量标记法与惰性清理的执行。当清理完后，即可随时开始再一次的标记。这样就能减少明显的停顿 并发标记与并行标记并发标记支持在主线程进行GC的时候启动多个worker thread一起执行GC。应用程序在整个并发标记阶段暂停，它是 stop-the-world 标记的多线程版本。 并行标记则是在主线程还在运行时即可启动多个worker thread执行GC，应用程序可以继续运行。 具体细节可参考引擎V8推出“并发标记”，可节省60%-70%的GC时间 四、内存问题内存泄漏什么是内存泄漏？ 内存泄漏指的是在执行垃圾回收的时候， 由于一些原因导致本应释放掉的空间没有被释放掉。 常见的内存泄漏循环引用在浏览器早起采用引用计数法的时候，如果两个变量相互引用，则其引用数始终为1，而垃圾回收只会对引用数为0的变量进行回收，这时就导致了内存泄漏。这也是为什么现在大都采用的标记清理法 没有被销毁的全局变量和计时器123456789101112function fn(){ bar = 'bar'; // 声明了全局变量}fn();var timer = getStart();getStart(function() { var temp = document.getElementById('temp'); if(temp) { temp.innerHTML = JSON.stringify(temp); }}, 5000); // 每5秒调用一次 此时若不手动置为null/调用clearInterval，则该变量和计时器将会一直存在，造成内存泄漏。直到window对象被销毁。 闭包1234567var closure = function(){ var count = 0; return function(){ return count++ }}const fn = closure(); 由于被返回的函数一直持有其外层函数closure的变量count导致count无法被回收，造成内存泄漏。所以能少用闭包就少用，或者用完及时置为null。 内存溢出内存溢出是一种程序运行的错误。指的是当程序运行需要的内存超过了剩余内存的时候，就会抛出内存溢出的错误。 内存泄漏积累过多时，就会导致内存溢出。 频繁的垃圾回收通过上文我们可以知道，早期的垃圾回收是单线程的，执行时会引起主线程的停顿。过于频繁的垃圾回收会造成程序的卡顿。 后来加入的并行标记和并发标记都是为了解决这个主线程卡顿的问题，但是否被现在的主流浏览器采用还是不太清楚。 五、Es6 WeakMap为了解决内存泄漏这个问题，ES6添加了WeakMap和WeakSet两个数据结构。他们对于值的引用都是不计入垃圾回收机制的，所以名字里才会有一个Weak，表示弱引用。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 参考文章 【译】V8 之旅： 垃圾回收器（想了解细节方面的可以看看） 原文（翻译的看起来可能会有些不易理解，建议结合起来看） javascript垃圾回收机制 JavaScript执行机制之垃圾回收 引擎V8推出“并发标记”，可节省60%-70%的GC时间 JavaScript 内存管理以及垃圾回收机制（引用计数、标记清除） 图解 JavaScript 垃圾回收 — 现代 JavaScript 教程 MDN","link":"/2022/09/02/JavaScript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"title":"generator与async&#x2F;await","text":"async和await是generator和Promise的语法糖，本质上是是将 Generator 函数和自动执行器，包装在一个函数里 123456789async function fn(args) { // ...}// 等同于function fn(args) { return spawn(function* () { // ... });} spawn函数的实现，是Thunk函数的一种体现 12345678910111213141516171819202122function spawn(genF){ return new Promise(function(trdolve, reject){ const gen = genF(); function step(nextF){ let next; try{ next = nextF(); }catch(e){ return reject(e); }; if(next.done){ return resolve(next.value); }; Promise.resolve(next.value).then(function(v){ step(function(){ return gen.next(v); }); },function(e){ step(function(){ return gen.throw(e); }); }); } step(function(){ return gen.next(undefined); }); })} Thunk函数1234567891011121314let x = 1;function f(m){ return m*2;}f(x+5)// 等同于let thunk = function(){ return x+5;}function f(thunk){ return thunk() * 2;} 编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数 Thunk函数的一大亮点就是其自动流程管理，也是Generator函数自动执行器的实现原理。 通过thunk函数，我们能够自动化交付控制权 12345678910111213141516function run(fn){ let gen = fn(); function next(err, data){ let result = gen.next(data); if(result.done) return; result.value(next); } next();}function* g(){ // ...};run(g); 我们都知道generator函数本身的执行需要通过next方法配合yield操作指针来放行任务，将控制权交接。但async和await并未出现相关的操作，只需要我们声明async函数和await的代码即可，函数会按顺序依次执行。 这本质上是通过thunk函数的自动执行的特点和Promise的状态实现的。通过thunk函数，我们可以不用手动调用next，而是通过判断上一次next的执行结果是否结束(done是否为true)来继续执行或跳出 通过Promise的then方法，生成一个新的Peomise对象，链式、递归的去执行下一个next方法，直到发现done为true为止。","link":"/2022/09/02/generator%E4%B8%8Easync%E3%80%81await/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 折叠代码块可选文件名 >folded1...代码块内容...","link":"/2022/09/01/hello-world/"},{"title":"hbuilder 启动微信开发者工具失败问题汇总","text":"检查步骤微信开发者工具安装位置打开hbuilder中的Settings.json 运行=&gt;运行到小程序模拟器=&gt;运行设置 找到 微信开发者工具路径，检查配置是否有误 检查微信开发者工具端口号配置打开微信开发者工具，在安全选项里开启服务端口 重点检查是否配置 appId如果上面的两步都没有问题，那么应该就是appid的问题了。首先要搞清楚的是 DCloud的AppId和微信开发者工具的AppId是不一样的。微信开发者工具的AppId在manifest.json内微信小程序里面 微信开发者工具的appId需要在微信公众平台获取。 如果使用游客登录微信开发者工具，而在hbuilder的 manifest.json=&gt;微信小程序 写了appId的话，是无法正常打开微信开发者工具的。 12345678910:26:33.467 正在启动微信开发者工具...10:26:35.496 [微信小程序开发者工具] [error] Error: Fail to open IDE10:26:35.496 [微信小程序开发者工具]10:26:35.499 [微信小程序开发者工具] - initialize10:26:35.500 [微信小程序开发者工具]10:26:35.502 [微信小程序开发者工具] √ IDE server has started, listening on http://127.0.0.1:2500710:26:35.503 [微信小程序开发者工具] - open IDE10:26:35.506 [微信小程序开发者工具]10:26:35.506 [微信小程序开发者工具] × open IDE 针对上面的问题，有两种方法解决 一个是在微信开发者平台上申请appId并更改项目中的appId 删除项目中微信小程序的appId，这样就能够在hbuilder中启动游客身份的微信开发者工具","link":"/2022/09/02/hbuilder%E5%90%AF%E5%8A%A8%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"},{"title":"国际化添加","text":"选择指定语言在 icarus 中，语言默认是英语，在&lt;root&gt;/_config.yml中的 language 选项中可以看到 当前为 en。我们需要先将其修改为期望的语言，这里我修改的是 zh-CN 即简体中文。 修改完后，能看到大部分地方都变成了中文，但是导航栏仍是英文。这是因为该主题并为对导航栏做国际化处理，导航栏是交由我们在 &lt;root&gt;/_config.icarus.yml 中去配置的，可以直接以汉字作为key值。 但总归是有点不舒服吧，所以想把这些东西也简单国际化一下，顺便看看是哪部分在起作用。 如果不想学jsx语法的可以直接以汉字为key值，因为涉及到部分源码的更改 在选中的语言中完善国际化配置国际化相关的文件存放在 &lt;root&gt;/themes/icarus/languages 里面，在 zh-CN.yml 添加 menu 选项（名字自定，见名知意即可） 12345678910111213141516menu: Home: one: '首页' other: '首页' Archives: one: '归档' other: '归档' Categories: one: '分类' other: '分类' Tags: one: '标签' other: '标签' About: one: '关于' other: '关于' 有其他想放上去的需要国际化的部分直接写即可，但是要记得在控制 menu 显示的地方加上对应的选项，此处针对 menu 国际化，并不控制显示与否 对于 other 还不是很明白，参考了下面原有的 common 这样，针对导航栏国际化的配置文件就补充ok了。 源码更改打开&lt;root&gt;/themes/icarus/layout/common/navbar.jsx ctrl+f 找到 Object.keys(navbar.menu) 这部分，因为主题未针对其做国际化处理，所以我们完善menu对象。对遍历做如下处理 12345678Object.keys(navbar.menu).forEach(name =&gt; { const url = url_for(navbar.menu[name]); const active = isSameLink(url, pageUrl); // __ 方法用于一般使用，_p 方法用于复数字符串使用 // 此处是通过辅助函数获取翻译后的字符串 const title = _p(`menu.${name}`) menu[name] = { title, url, active };}); 在Dom处修改显示 123456 {Object.keys(menu).length ? &lt;div class=&quot;navbar-start&quot;&gt; {Object.keys(menu).map(name =&gt; { const item = menu[name]; return &lt;a class={classname({ 'navbar-item': true, 'is-active': item.active })} href={item.url}&gt;{item.title}&lt;/a&gt;; })}&lt;/div&gt; : null} 至此，nav国际化添加完毕。","link":"/2022/09/02/%E5%85%B3%E4%BA%8E%E5%9B%BD%E9%99%85%E5%8C%96/"},{"title":"函数式触发click和点击触发click在宏任务与微任务方面的区别","text":"用例： 1234567891011121314// 先通过点击执行 var btn = document.querySelector('#btn') btn.addEventListener('click', ()=&gt;{ Promise.resolve().then(()=&gt;console.log(&quot;Microtask 1&quot;)); console.log(&quot;Listener 1&quot;); }) btn.addEventListener('click', ()=&gt;{ Promise.resolve().then(()=&gt;console.log(&quot;Microtask 2&quot;)); console.log(&quot;Listener 2&quot;); })// Listener 1// Microtask 1// Listener 2// Microtask 2 12345678910111213141516// 通过函数调用 var btn = document.querySelector('#btn') btn.addEventListener('click', ()=&gt;{ Promise.resolve().then(()=&gt;console.log(&quot;Microtask 1&quot;)); console.log(&quot;Listener 1&quot;); }) btn.addEventListener('click', ()=&gt;{ Promise.resolve().then(()=&gt;console.log(&quot;Microtask 2&quot;)); console.log(&quot;Listener 2&quot;); }) btn.click();// Listener 1// Listener 2// Microtask 1// Microtask 2 说一下自己的理解，在网上找了好久，并没有一个确切的描述这种结果产生的原因。上述两种结果的原因在于调用栈是否清空。也可以说是当前宏任务是否执行完毕。 点击触发当我们通过addEventListener向按钮去添加事件时，实际上是添加在了其事件侦听器列表中，可以通过getListeners去查看所有的事件。 在直接点击DOM时，会向调用栈依次添加Listener，当第一个Listener执行完后，调用栈清空。此时在下一个Listener的添加/执行之前，会先处理微任务队列，从调用栈的角度看，两个Listener属于两个不同的宏任务。具体结果就是第一个例子的 Listener1、Microtask1、Listener2、Microtask2。 函数调用在通过函数调用的时候，首先会向调用栈内添加click的调用，然后依次去执行该DOM上绑定的事件，在执行完第一个Listener中的事件后，没有return语句存在，所以click函数仍处于调用状态，调用栈并未弹出，在第二个Listener执行时仍处于同一个宏任务，所以也就有了下面的结果：Listener1、Listener2、Microtask1、、Microtask2。 补充上述说明并没有很好的资料支持，是从输出结果和Chrome控制台调用栈的显示反推的，如果有什么问题还请及时指出。","link":"/2022/09/02/%E5%87%BD%E6%95%B0%E5%BC%8F%E8%A7%A6%E5%8F%91click%E5%92%8C%E7%82%B9%E5%87%BB%E8%A7%A6%E5%8F%91click%E5%9C%A8%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"从开源框架el-admin中学习状态模式","text":"状态模式的定义与特点状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。 State抽象状态角色 接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。 ConcreteState具体状态角色 具体状态主要有两个职责:一是处理本状态下的事情，二是从本状态如何过渡到其他状态。 Context环境角色 定义客户端需要的接口，并且负责具体状态的切换。 eladmin框架混入及封装用的比较多，导致我也不能很具体的判断出来具体的角色指的是谁，如果有知道的还请留言告诉我，谢谢。 在eladmin中，框架对数据的新增和表单的编辑、删除都通过状态模式去处理了部分逻辑判断。框架并不是针对某个具体的组件进行的状态处理，而是针对的整个过程进行的状态处理。不同组件通过该过程的不同状态，也会有不同的表现形式，例如按钮的loading显示、表单的标题与显示、方法处理的逻辑等。 下面主要以新增数据为例，具体介绍下eladmin中状态模式的实现。 数据新增在eladmin中的状态定义 123456789// src/compents/Crud/crud.js/** * CRUD状态 */CRUD.STATUS = { NORMAL: 0, PREPARED: 1, PROCESSING: 2} 关键组件 1234567891011121314151617181920212223// src/compents/Crud/CRUD.operation.vue&lt;template&gt; ... &lt;el-button v-if=&quot;crud.optShow.add&quot; v-permission=&quot;permission.add&quot; class=&quot;filter-item&quot; size=&quot;mini&quot; type=&quot;primary&quot; icon=&quot;el-icon-plus&quot; @click=&quot;crud.toAdd&quot; &gt; 新增 &lt;/el-button&gt; ...&lt;/template&gt;&lt;script&gt;// 该处通过混入的方式将crud的方法引进来import CRUD, { crud } from '@/compents/Crud//crud.js'export default { mixins: [crud()],}&lt;/script&gt; 这里主要混入的是一些逻辑处理的方法、CRUD状态定义和一些关键的data数据混入后的关键属性有下面这些 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// src/compents/Crud/CRUD.operation.vue&lt;template&gt; ... &lt;el-button v-if=&quot;crud.optShow.add&quot; v-permission=&quot;permission.add&quot; class=&quot;filter-item&quot; size=&quot;mini&quot; type=&quot;primary&quot; icon=&quot;el-icon-plus&quot; @click=&quot;crud.toAdd&quot; &gt; 新增 &lt;/el-button&gt; ...&lt;/template&gt;&lt;script&gt;export default { data() { return { // 通过混入进来的 // ... 省略多余的属性 status: { add: CRUD.STATUS.NORMAL, edit: CRUD.STATUS.NORMAL, // 添加或编辑状态 // 表单、按钮loading等组件的状态都是根据这里判断的 get cu() { if (this.add === CRUD.STATUS.NORMAL &amp;&amp; this.edit === CRUD.STATUS.NORMAL) { return CRUD.STATUS.NORMAL } else if (this.add === CRUD.STATUS.PREPARED || this.edit === CRUD.STATUS.PREPARED) { return CRUD.STATUS.PREPARED } else if (this.add === CRUD.STATUS.PROCESSING || this.edit === CRUD.STATUS.PROCESSING) { return CRUD.STATUS.PROCESSING } throw new Error('wrong crud\\'s cu status') }, // 标题，控制表单Dialog组件标题在不同状态下的显示 get title() { return this.add &gt; CRUD.STATUS.NORMAL ? `新增${crud.title}` : this.edit &gt; CRUD.STATUS.NORMAL ? `编辑${crud.title}` : crud.title } } } }, methods:{ // ... 省略多余的方法 /** * 启动添加 */ toAdd() { // 重置表单数据 crud.resetForm() // 对自定义钩子进行处理，如果设置了就执行 if (!(callVmHook(crud, CRUD.HOOK.beforeToAdd, crud.form) &amp;&amp; callVmHook(crud, CRUD.HOOK.beforeToCU, crud.form))) { return } // 更改add的状态，从NORMAL变为PREPARED crud.status.add = CRUD.STATUS.PREPARED // 此时会弹出来el-dialog。该弹框通过:visible.sync=&quot;crud.status.cu &gt; 0&quot;控制显示 // 对自定义钩子进行处理，如果设置了就执行 callVmHook(crud, CRUD.HOOK.afterToAdd, crud.form) callVmHook(crud, CRUD.HOOK.afterToCU, crud.form) }, /** * 提交新增/编辑 */ submitCU() { if (!callVmHook(crud, CRUD.HOOK.beforeValidateCU)) { return } // 找到当前根据status显示的form组件，并进行校验 crud.findVM('form').$refs['form'].validate(valid =&gt; { if (!valid) { return } // 是否执行钩子 if (!callVmHook(crud, CRUD.HOOK.afterValidateCU)) { return } // 根据状态去判断具体的执行方法 if (crud.status.add === CRUD.STATUS.PREPARED) { crud.doAdd() } else if (crud.status.edit === CRUD.STATUS.PREPARED) { crud.doEdit() } }) }, /** * 执行添加 */ doAdd() { // 自定义钩子 if (!callVmHook(crud, CRUD.HOOK.beforeSubmit)) { return } // 更改整个添加过程的状态为PROCESSING crud.status.add = CRUD.STATUS.PROCESSING // 调取添加接口(此处eladmin做了一定处理，通过crudMethod和其属性即可调取自己定义的接口地址) crud.crudMethod.add(crud.form).then(() =&gt; { // 成功后将状态更改为初始状态 = 关闭表单，停止loading crud.status.add = CRUD.STATUS.NORMAL crud.resetForm() crud.addSuccessNotify() callVmHook(crud, CRUD.HOOK.afterSubmit) crud.toQuery() }).catch(() =&gt; { // 出错后就更改为PREPARED状态(新增的第二个状态，此时表单仍然存在) crud.status.add = CRUD.STATUS.PREPARED callVmHook(crud, CRUD.HOOK.afterAddError) }) }, }}&lt;/script&gt; 简单来说，eladmin通过状态模式针对整个添加的流程做了如下规定： NORMAL阶段 表单控件不显示 按钮loading为false 点击新增，进入PREPARED阶段 表单显示，获取该阶段表单对应的标题 点击确定，进入PROCESSING阶段 显示loading 发出请求 如果成功，重新设置为NORMAL阶段 如果失败，则回到PREPARED阶段 总结整个过程涉及到的组件有很多，只不过表单和按钮是最显眼的，并且按钮有很多个。框架通过状态模式将很多按钮的判断逻辑抽离了出来，减少了不少工作量。通过状态的判断去控制了各个组件自己的表现形式，在后期维护时也更加容易。 后面有人接手的话也只需要关注关键方法的逻辑。而不是散落在各个组件中的小按钮和表单样式的逻辑了(假如不使用该模式)。","link":"/2022/09/02/%E4%BB%8E%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6el-admin%E4%B8%AD%E5%AD%A6%E4%B9%A0%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"title":"秒杀倒计时（准确计时）","text":"方案1确认服务端与客户端的时间差 首先，时间肯定是按服务器的时间 serverTime 为主，客户端通过通过请求接口获取服务端的时间。运营取设置开始时间 startTime 运营需要设置startTime，通过startTime与serverTime相减即为活动在各个手机上的真实的剩余时间。 因为前端在进行 setTimeout 或 setInterval 时，会有时间的偏差，所以需要在该阶段消除误差。可以在执行新的 setTimeout 时将误差考虑进去，进行提前执行（一般都是1000ms更新一次）1234567891011121314151617181920212223242526272829//继续线程占用setInterval(function(){ var j = 0; while(j++ &lt; 100000000); }, 0); //倒计时var interval = 1000, ms = 50000, //从服务器和活动开始时间计算出的时间差，这里测试用50000ms count = 0, startTime = new Date().getTime();if( ms &gt;= 0){ var timeCounter = setTimeout(countDownStart,interval); } function countDownStart(){ count++; var offset = new Date().getTime() - (startTime + count * interval); var nextTime = interval - offset; var daytohour = 0; if (nextTime &lt; 0) { nextTime = 0 }; ms -= interval; console.log(&quot;误差：&quot; + offset + &quot;ms，下一次执行：&quot; + nextTime + &quot;ms后，离活动开始还有：&quot; + ms + &quot;ms&quot;); if(ms &lt; 0){ clearTimeout(timeCounter); }else{ timeCounter = setTimeout(countDownStart,nextTime); } } 当阻塞过长的时候，需要另外处理。 方案2使用requestAnimationFrame每16.7ms执行一次，但是也会存在不准确的情况本质上是将函数作为requestAnimationFrame的回调去执行以实现计时效果（函数内部继续执行requestAnimationFrame，并将函数自己传入） 方案3使用webWorker利用worker去处理计时，思路和方案1类似。","link":"/2022/09/02/%E7%A7%92%E6%9D%80%E5%80%92%E8%AE%A1%E6%97%B6%EF%BC%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%86%E7%A1%AE%E8%AE%A1%E6%97%B6%EF%BC%89/"},{"title":"设计模式：单例模式","text":"前言学习了这么长的时间，设计模式却还是浅尝辄止，而且最近在回顾Vue知识的时候，发现了很多常见的设计模式：观察者啊，单例啊什么的。让我意识到，如果想要去读懂Vue底层的话，设计模式的思想是必不可少的。 虽然是在学前端，但是准备通过java来学习设计模式，因为毕竟java是一个强类型的语言，通过java能更直观的去学习设计模式的思想。同时也会尽量去将设计模式通过JavaScript的方式实现出来。 什么是单例模式字面上来看，就是只有一个实例的模式。简单来说，单例模式就是在整个系统中，保持一个实例，不生成新实例的模式。当然并不是说仅仅只能new一个对象出来，而是说，针对某个特殊的对象，我们在第一次将它实例化后，以后再次访问时，访问到的一直都是之前实例化好的特殊对象。 为什么需要单例模式正如上面说的那样，单例模式针对的是某些特殊的对象，那么该对象为什么被针对呢？ 需要单例模式实现的对象或系统，一般具有如下特点： 对象 需要频繁的被创建、销毁，但在这些过程中无法优化 需要比较多的资源：读取配置、产生其他依赖对象 环境 希望节省内存 希望节省系统性能的开销 希望某些资源不被多重占用 希望有一个能够统一处理资源和优化的对象 Vuex和Spring中的Bean对象就是如此 通过单例模式，我们能够简单的实现节省性能开销、节省内存、统一管理资源等功能。因为只有一个实例对象存在，并不会新生成。 如何实现单例模式单例模式的实现要点 保证对象只有一个，不能生成新对象出来 JavaScript实现的条件还是不变，保证对象只有一个，不能生成新对象出来。在JavaScript中，如果要实现私有化，首先想到的就是闭包了，闭包还能够使该实例不消失。其次结合if判断语句，如果实例存在，直接返回，不存在就执行new运算符初始化实例。 闭包实现1234567891011121314151617let SingleCase = (function Singleton (){ let instance = null function _init(){ // 此处可以定义一些初始化配置 } return function(){ console.log(instance) if(!instance){ instance = new _init() } return instance }})()var a = SingleCase()var b = SingleCase()a === b // true 其实js中window顶层对象就是个单例了。 Es6 Class实现首先我们要明白，Class是一个语法糖，本质上也是一个构造函数。回顾单例的要求，一是共享一个实例，二是不能生成新实例出来 构造函数 constructorClass有一个特点，在我们实例化Class时，会自动执行其内的constructor函数（每一个Class都有该函数，不声明默认为空。），可以初始化一些配置。 12345678910111213class Singleton{ constructor() { if(!Singleton.instance) { // 进行一些初始化操作 this.name = '张三' Singleton.instance = this } return Singleton.instance } }var a = new Singleton()var b = new Singleton()a === b // true 上面的方法能够实现单例的要点在于，只有第一个new Singleton()是真真的new出来的，之后的其实都是第一个new出来的实例对象。通过以下输出可以证明 12345678910111213class Singleton { constructor() { if(!Singleton.instance) { // 判断有无实例存在，若无则返回当前实例 window.first = this // 存储第一个实例 Singleton.instance = this // 将第一个实例赋值给Singleton.instance } window.second = this // 记录最新创建的实例 return Singleton.instance // 返回第一个实例 } }var a = new Singleton()var b = new Singleton()window.first === window.second // false 之所以该实例能够一直存在，是因为不仅仅后续创建的变量在引用它，而且Singleton本身的属性instance也在引用它，所以不会被销毁 静态方法/属性在Es6中，Class提供了静态方法。表示该方法为该类独有，不会被实例继承。我们可以通过静态方法来实现单例 12345678910// 静态方法class Singleton{ static getInstance() { if (!Singleton.instance) { Singleton.instance = new Singleton() } return Singleton.instance }}Singleton.getInstance() === Singleton.getInstance() // true 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性 1234567// 静态属性(不是很确定这么用行不行，但是也能实现)class Singleton { static SingleCase = {};}var a = Singleton.SingleCasevar b = Singleton.SingleCasea === b // true Vuex的实现思路by——Controllerszzy 123456789101112131415161718192021222324class SingleState { // 状态存储机制 data={} // 获取对象 get(key){ return this.data[key]||'' } // 存储对象 set(key,value){ return this.data[key]=value } // 外部调用此函数实例化 static getInstance() { if (!SingleState.instance) { SingleState.instance = new SingleState } return SingleState.instance }}const state_1 = SingleState.getInstance()state_1.set('hi','hello') // 设置 key = hi value = helloconst state_2 = SingleState.getInstance()console.log(state_2.get('hi')) // hello 使用过程中通过 Vue.use(Vuex) 安装了Vuex插件,而Vuex 插件是一个对象，它在内部实现了一个 install 方法，这个方法会在插件安装时被调用，从而把 Store 注入到Vue实例里去。也就是说每 install 一次，都会尝试给 Vue 实例注入一个 Store。 单例模式的优劣总结优点 减少了内存开支 减少了系统的性能开销 避免对资源的多重占用 设置全局的访问点， 优化和共享资源访问 缺点 扩展很困难 对测试是不利的 与单一职责原则有冲突 一个类应该只实现一个逻辑， 而不关心它是否是单例的， 是不是要单例取决于环境， 单例模式把“要单例”和业务逻辑融合在一个类中 对ES6中新增类型Symbol的疑问Symbol的实现或者用法和单例有什么联系呢？感觉上挺像的，虽然只是用于防止命名冲突。Es6一直不太会用出来，所以理解的也不是很到位。 总结其实单例模式还区分饿汉和懒汉两种模式，其差别在于：饿汉要求直接生成实例，不管有没有调用该对象懒汉要求什么时候用到了，什么时候再生成这个实例对象 补充学习了js一段时间后，发现之前js实现的单例是比较局限的，自己并没有从一个前端的角度去思考设计模式如何实现。所以在阅读了《JavaScript设计模式与开发实践》后，来补充下最新的理解。 上述闭包实现的单例存在着一些问题 单例的判断逻辑和单例对象的创建混杂在了一起。假如想去创建其他非单例对象时，需要重新在再写一部分相同的创建逻辑，所以，我们需要把二者拆分开，以实现 单一职责原则 12345678910111213141516171819// 单例逻辑的控制const getSingle = (fn)=&gt; { let result; return function(){ return result || (result = fn.call(result,arguments)); }}// 可复用的创建各种各样东西的方法const createObj = ()=&gt; {discribe:'创建对象的方法'};const createDiv = ()=&gt; {discribe:'创建Div的方法'};// 通过高阶函数，这样就准备好了创建单例的方法const createSingleObj = getSingle(createObj);const createSingleDiv = getSingle(createDiv );const a = createSingleObj();const b = createSingleObj();console.log(a === b) // true","link":"/2022/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"根据组件类型与条件动态添加下拉框及选项","text":"前言本次在做低代码平台时，遇见了一个稍微有些复杂的业务场景，需求描述： 根据用户拖拽表单生成的JSON数据(本次采用了FormGenerator去生成JSON数据)，生成对应的所有组件的下拉列表，并在流程图的边（节点连接线）上添加条件判断。 当用户点击流程图的边时，生成该边上对应的所有组件的下拉列表，在点击某个组件的选项后，生成对应组件的下拉列表组件，在用户取消选择后，对应组件的下拉列表组件随之消失。 针对不同组件对应的下拉列表，要求有不同的条件判断，例如：数字类型的需要有范围选择、大小判断、为空不为空，等条件；文本组件有包含不包含，等条件。 当用户选择后，自动保存到当前边对应的JSON数据，若用户的选择无效，则不保存。 要求能够回显用户选择的数据，即点击不同边时，回显该边上JSON对应的所有下拉列表组件。 经过梳理后，其实逻辑看起来也不是特别复杂，不过当时确实是有点被难倒了，主要原因就是一些细节性的问题没有考虑到，然后流程图也需要去学习如何操作，时间上有些紧，同时也在思考如何写能够更便于维护。其次就是没有一个清晰的该处业务的流程思考，不过后来捋了捋也就差不多啦，所以说三思而后行啊。 三思而后行：多思考几遍，自己又觉得自己行了哈哈 Logicflow和FromGenerator就不多说了，虽然也有点坑，但都是轮子，主要记录下这块业务场景如何实现的。 组件展示 包含所有组件的下拉列表 对应组件的下拉列表组件 根据条件改变输入形式 具体实现JSON数据处理处理JSON，不得不提一嘴ES6结构赋值，属实是属性提取的利器。原JSON大概长这个样子，为了区别不同类型的组件，和表单那边的小伙伴约定了两个字段，tag用于区分组件输入框的类型，typeNumber用于区分下拉列表内容有哪些 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302{ &quot;fields&quot;: [ { &quot;__config__&quot;: { &quot;label&quot;: &quot;单行文本&quot;, &quot;labelWidth&quot;: null, &quot;showLabel&quot;: true, &quot;changeTag&quot;: true, &quot;tag&quot;: &quot;el-input&quot;, &quot;tagIcon&quot;: &quot;input&quot;, &quot;required&quot;: true, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;span&quot;: 24, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/input&quot;, &quot;regList&quot;: [], &quot;formId&quot;: 101, &quot;renderKey&quot;: 1649927471934, &quot;typeNumber&quot;: 0 }, &quot;__slot__&quot;: { &quot;prepend&quot;: &quot;&quot;, &quot;append&quot;: &quot;&quot; }, &quot;placeholder&quot;: &quot;请输入单行文本&quot;, &quot;style&quot;: { &quot;width&quot;: &quot;100%&quot; }, &quot;clearable&quot;: true, &quot;prefix-icon&quot;: &quot;&quot;, &quot;suffix-icon&quot;: &quot;&quot;, &quot;maxlength&quot;: null, &quot;show-word-limit&quot;: false, &quot;readonly&quot;: false, &quot;disabled&quot;: false, &quot;__vModel__&quot;: &quot;field101&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;多行文本&quot;, &quot;labelWidth&quot;: null, &quot;showLabel&quot;: true, &quot;tag&quot;: &quot;el-input&quot;, &quot;tagIcon&quot;: &quot;textarea&quot;, &quot;required&quot;: true, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;span&quot;: 24, &quot;regList&quot;: [], &quot;changeTag&quot;: true, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/input&quot;, &quot;formId&quot;: 102, &quot;typeNumber&quot;: 1, &quot;renderKey&quot;: 1649927472786 }, &quot;type&quot;: &quot;textarea&quot;, &quot;placeholder&quot;: &quot;请输入多行文本&quot;, &quot;autosize&quot;: { &quot;minRows&quot;: 4, &quot;maxRows&quot;: 4 }, &quot;style&quot;: { &quot;width&quot;: &quot;100%&quot; }, &quot;maxlength&quot;: null, &quot;show-word-limit&quot;: false, &quot;readonly&quot;: false, &quot;disabled&quot;: false, &quot;__vModel__&quot;: &quot;field102&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;级联选择&quot;, &quot;showLabel&quot;: true, &quot;labelWidth&quot;: null, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;tagIcon&quot;: &quot;cascader&quot;, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;defaultValue&quot;: [ 1, 2 ], &quot;dataType&quot;: &quot;dynamic&quot;, &quot;span&quot;: 24, &quot;required&quot;: true, &quot;regList&quot;: [], &quot;changeTag&quot;: true, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/cascader&quot;, &quot;formId&quot;: 111, &quot;typeNumber&quot;: 9, &quot;renderKey&quot;: 1649942215947 }, &quot;options&quot;: [ { &quot;id&quot;: 1, &quot;value&quot;: 1, &quot;label&quot;: &quot;选项1&quot;, &quot;children&quot;: [ { &quot;id&quot;: 2, &quot;value&quot;: 2, &quot;label&quot;: &quot;选项1-1&quot; } ] } ], &quot;placeholder&quot;: &quot;请选择级联选择&quot;, &quot;style&quot;: { &quot;width&quot;: &quot;100%&quot; }, &quot;props&quot;: { &quot;props&quot;: { &quot;multiple&quot;: false, &quot;label&quot;: &quot;label&quot;, &quot;value&quot;: &quot;value&quot;, &quot;children&quot;: &quot;children&quot; } }, &quot;show-all-levels&quot;: true, &quot;disabled&quot;: false, &quot;clearable&quot;: true, &quot;filterable&quot;: false, &quot;separator&quot;: &quot;/&quot;, &quot;__vModel__&quot;: &quot;field111&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;计数器&quot;, &quot;showLabel&quot;: true, &quot;changeTag&quot;: true, &quot;labelWidth&quot;: null, &quot;tag&quot;: &quot;el-input-number&quot;, &quot;tagIcon&quot;: &quot;number&quot;, &quot;span&quot;: 24, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;required&quot;: true, &quot;regList&quot;: [], &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/input-number&quot;, &quot;formId&quot;: 105, &quot;typeNumber&quot;: 2, &quot;renderKey&quot;: 1649927477883 }, &quot;placeholder&quot;: &quot;计数器&quot;, &quot;step&quot;: 1, &quot;step-strictly&quot;: false, &quot;controls-position&quot;: &quot;&quot;, &quot;disabled&quot;: false, &quot;__vModel__&quot;: &quot;field105&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;下拉选择&quot;, &quot;showLabel&quot;: true, &quot;labelWidth&quot;: null, &quot;tag&quot;: &quot;el-select&quot;, &quot;tagIcon&quot;: &quot;select&quot;, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;span&quot;: 24, &quot;required&quot;: true, &quot;regList&quot;: [], &quot;changeTag&quot;: true, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/select&quot;, &quot;formId&quot;: 106, &quot;typeNumber&quot;: 6, &quot;renderKey&quot;: 1649927484505 }, &quot;__slot__&quot;: { &quot;options&quot;: [ { &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 } ] }, &quot;placeholder&quot;: &quot;请选择下拉选择&quot;, &quot;style&quot;: { &quot;width&quot;: &quot;100%&quot; }, &quot;clearable&quot;: true, &quot;disabled&quot;: false, &quot;filterable&quot;: false, &quot;multiple&quot;: false, &quot;__vModel__&quot;: &quot;field106&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;单选框组&quot;, &quot;labelWidth&quot;: null, &quot;showLabel&quot;: true, &quot;tag&quot;: &quot;el-radio-group&quot;, &quot;tagIcon&quot;: &quot;radio&quot;, &quot;changeTag&quot;: true, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;span&quot;: 24, &quot;optionType&quot;: &quot;default&quot;, &quot;regList&quot;: [], &quot;required&quot;: true, &quot;border&quot;: false, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/radio&quot;, &quot;formId&quot;: 107, &quot;typeNumber&quot;: 4, &quot;renderKey&quot;: 1649927491036 }, &quot;__slot__&quot;: { &quot;options&quot;: [ { &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 } ] }, &quot;style&quot;: {}, &quot;size&quot;: &quot;medium&quot;, &quot;disabled&quot;: false, &quot;__vModel__&quot;: &quot;field107&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;多选框组&quot;, &quot;tag&quot;: &quot;el-checkbox-group&quot;, &quot;tagIcon&quot;: &quot;checkbox&quot;, &quot;defaultValue&quot;: [], &quot;span&quot;: 24, &quot;showLabel&quot;: true, &quot;labelWidth&quot;: null, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;optionType&quot;: &quot;default&quot;, &quot;required&quot;: true, &quot;regList&quot;: [], &quot;changeTag&quot;: true, &quot;border&quot;: false, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/checkbox&quot;, &quot;formId&quot;: 108, &quot;typeNumber&quot;: 5, &quot;renderKey&quot;: 1649927491380 }, &quot;__slot__&quot;: { &quot;options&quot;: [ { &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 } ] }, &quot;style&quot;: {}, &quot;size&quot;: &quot;medium&quot;, &quot;disabled&quot;: false, &quot;__vModel__&quot;: &quot;field108&quot; }, { &quot;__config__&quot;: { &quot;label&quot;: &quot;日期选择&quot;, &quot;tag&quot;: &quot;el-date-picker&quot;, &quot;tagIcon&quot;: &quot;date&quot;, &quot;defaultValue&quot;: null, &quot;showLabel&quot;: true, &quot;labelWidth&quot;: null, &quot;span&quot;: 24, &quot;layout&quot;: &quot;colFormItem&quot;, &quot;required&quot;: true, &quot;regList&quot;: [], &quot;changeTag&quot;: true, &quot;document&quot;: &quot;https://element.eleme.cn/#/zh-CN/component/date-picker&quot;, &quot;formId&quot;: 110, &quot;typeNumber&quot;: 3, &quot;renderKey&quot;: 1649927506700 }, &quot;placeholder&quot;: &quot;请选择日期选择&quot;, &quot;type&quot;: &quot;date&quot;, &quot;style&quot;: { &quot;width&quot;: &quot;100%&quot; }, &quot;disabled&quot;: false, &quot;clearable&quot;: true, &quot;format&quot;: &quot;yyyy-MM-dd&quot;, &quot;value-format&quot;: &quot;yyyy-MM-dd&quot;, &quot;readonly&quot;: false, &quot;__vModel__&quot;: &quot;field110&quot; } ], &quot;formRef&quot;: &quot;elForm&quot;, &quot;formModel&quot;: &quot;formData&quot;, &quot;size&quot;: &quot;medium&quot;, &quot;labelPosition&quot;: &quot;right&quot;, &quot;labelWidth&quot;: 100, &quot;formRules&quot;: &quot;rules&quot;, &quot;gutter&quot;: 15, &quot;disabled&quot;: false, &quot;span&quot;: 24, &quot;formBtns&quot;: true, &quot;unFocusedComponentBorder&quot;: false} 解构工具类解构赋值 过滤数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204// utils/adpterForForm.js// 依照tag判断组件输入框的类型(FormGenerator采用的elementui，所以会有el-xxx的tag)const contentTypeMap = { 'el-input': 'input', 'el-textarea': 'input', 'el-input-number': 'input', 'el-date-picker': 'date', 'el-radio-group': 'select', 'el-checkbox-group': 'select', 'el-select': 'select', 'el-cascader': 'tree', 'el-upload': 'none'};// { label: '等于', value: 0 },// { label: '不等于', value: 1 },// { label: '包含', value: 2 },// { label: '不包含', value: 3 },// { label: '为空', value: 4 },// { label: '不为空', value: 5 }// { label: '大于', value: 6 },// { label: '大于等于', value: 7 },// { label: '小于', value: 8 },// { label: '小于等于', value: 9 },// { label: '选择范围', value: 10 },// { label: '等于任意一个', value: 11 },// { label: '不等于任意一个', value: 12 },// { label: '包含任意一个', value: 13 },// { label: '同时包含', value: 14 },// { label: '属于', value: 15 },// { label: '不属于', value: 16 },// { label: '已验证', value: 17 },// { label: '未验证', value: 18 },// 依照type判断组件所对应的下拉列表const judgeListMap = { // 单行文本 '0': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '包含', value: 2 }, { label: '不包含', value: 3 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 多行文本 '1': [ { label: '包含', value: 2 }, { label: '不包含', value: 3 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 数字 '2': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '大于', value: 6 }, { label: '大于等于', value: 7 }, { label: '小于', value: 8 }, { label: '小于等于', value: 9 }, { label: '选择范围', value: 10 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 日期时间 '3': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '大于等于', value: 7 }, { label: '小于等于', value: 9 }, { label: '选择范围', value: 10 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 单选按钮组 '4': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '等于任意一个', value: 11 }, { label: '不等于任意一个', value: 12 }, { label: '包含', value: 2 }, { label: '不包含', value: 3 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 复选框组 '5': [ { label: '等于', value: 0 }, { label: '包含任意一个', value: 13 }, { label: '同时包含', value: 14 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 单选列表 '6': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '等于任意一个', value: 11 }, { label: '不等于任意一个', value: 12 }, { label: '包含', value: 2 }, { label: '不包含', value: 3 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 复选列表 '7': [ { label: '等于', value: 0 }, { label: '包含任意一个', value: 13 }, { label: '同时包含', value: 14 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 地址 '9': [ { label: '属于', value: 15 }, { label: '不属于', value: 16 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 图片 '10': [ { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 附件 '11': [ { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 手机 '12': [ { label: '包含', value: 2 }, { label: '已验证', value: 17 }, { label: '未验证', value: 18 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 成员单选 '13': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '等于任意一个', value: 11 }, { label: '不等于任意一个', value: 12 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 成员多选 '14': [ { label: '等于', value: 0 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 }, { label: '包含任意一个', value: 13 }, { label: '同时包含', value: 14 } ], // 成员单选 '15': [ { label: '等于', value: 0 }, { label: '不等于', value: 1 }, { label: '等于任意一个', value: 11 }, { label: '不等于任意一个', value: 12 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 } ], // 部门多选 '16': [ { label: '等于', value: 0 }, { label: '为空', value: 4 }, { label: '不为空', value: 5 }, { label: '包含任意一个', value: 13 }, { label: '同时包含', value: 14 } ]};// 获取表单JSON数据中所有组件的必要信息，并存放在map中去，便于查询和管理export function getComponentMap (data) { // 声明一个map集合 const map = new Map(); // 遍历解构赋值每一项 for (const item of data) { const { '__config__': { 'label': label = '', 'renderKey': renderKey = '', 'tag': tag = '', 'typeNumber': type = '' }, '__slot__': { 'options': options = [] } = {} } = item; // 构造所需要的数据对象 const obj = { label: label, renderKey: renderKey, // 唯一标识 tag: tag, // 决定条件组件卡片的内容选择形式，因为文本输入框和数字、日期的展示形式不同 type: type, // 决定条件卡片的条件选项有哪些 options: options // 如果内容选项为下拉列表时，通过options展示 }; obj.judgeList = judgeListMap[obj.type]; // 依照type添加条件列表 obj.componentFormat = contentTypeMap[obj.tag]; // 依照tag添加内容展示形式 map.set(obj.renderKey, obj); // 依据组件的唯一标识去存放进map } return map;} 解构结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473[{ &quot;key&quot;: &quot;1011655792483713&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;单行文本&quot;, &quot;renderKey&quot;: &quot;1011655792483713&quot;, &quot;tag&quot;: &quot;el-input&quot;, &quot;type&quot;: 0, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;包含&quot;, &quot;value&quot;: 2 }, { &quot;label&quot;: &quot;不包含&quot;, &quot;value&quot;: 3 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;input&quot; }}, { &quot;key&quot;: &quot;1021655792484018&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;多行文本&quot;, &quot;renderKey&quot;: &quot;1021655792484018&quot;, &quot;tag&quot;: &quot;el-input&quot;, &quot;type&quot;: 1, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;包含&quot;, &quot;value&quot;: 2 }, { &quot;label&quot;: &quot;不包含&quot;, &quot;value&quot;: 3 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;input&quot; }}, { &quot;key&quot;: &quot;1031655792484335&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;数字&quot;, &quot;renderKey&quot;: &quot;1031655792484335&quot;, &quot;tag&quot;: &quot;el-input&quot;, &quot;type&quot;: 2, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;大于&quot;, &quot;value&quot;: 6 }, { &quot;label&quot;: &quot;大于等于&quot;, &quot;value&quot;: 7 }, { &quot;label&quot;: &quot;小于&quot;, &quot;value&quot;: 8 }, { &quot;label&quot;: &quot;小于等于&quot;, &quot;value&quot;: 9 }, { &quot;label&quot;: &quot;选择范围&quot;, &quot;value&quot;: 10 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;input&quot; }}, { &quot;key&quot;: &quot;1041655792484586&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;日期时间&quot;, &quot;renderKey&quot;: &quot;1041655792484586&quot;, &quot;tag&quot;: &quot;el-date-picker&quot;, &quot;type&quot;: 3, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;大于等于&quot;, &quot;value&quot;: 7 }, { &quot;label&quot;: &quot;小于等于&quot;, &quot;value&quot;: 9 }, { &quot;label&quot;: &quot;选择范围&quot;, &quot;value&quot;: 10 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;date&quot; }}, { &quot;key&quot;: &quot;1051655792484934&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;单选按钮组&quot;, &quot;renderKey&quot;: &quot;1051655792484934&quot;, &quot;tag&quot;: &quot;el-radio-group&quot;, &quot;type&quot;: 4, &quot;options&quot;: [{ &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 }], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;等于任意一个&quot;, &quot;value&quot;: 11 }, { &quot;label&quot;: &quot;不等于任意一个&quot;, &quot;value&quot;: 12 }, { &quot;label&quot;: &quot;包含&quot;, &quot;value&quot;: 2 }, { &quot;label&quot;: &quot;不包含&quot;, &quot;value&quot;: 3 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;select&quot; }}, { &quot;key&quot;: &quot;1061655792485183&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;复选框组&quot;, &quot;renderKey&quot;: &quot;1061655792485183&quot;, &quot;tag&quot;: &quot;el-checkbox-group&quot;, &quot;type&quot;: 5, &quot;options&quot;: [{ &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 }], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;包含任意一个&quot;, &quot;value&quot;: 13 }, { &quot;label&quot;: &quot;同时包含&quot;, &quot;value&quot;: 14 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;select&quot; }}, { &quot;key&quot;: &quot;1071655792485471&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;下拉框&quot;, &quot;renderKey&quot;: &quot;1071655792485471&quot;, &quot;tag&quot;: &quot;el-select&quot;, &quot;type&quot;: 6, &quot;options&quot;: [{ &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 }], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;等于任意一个&quot;, &quot;value&quot;: 11 }, { &quot;label&quot;: &quot;不等于任意一个&quot;, &quot;value&quot;: 12 }, { &quot;label&quot;: &quot;包含&quot;, &quot;value&quot;: 2 }, { &quot;label&quot;: &quot;不包含&quot;, &quot;value&quot;: 3 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;select&quot; }}, { &quot;key&quot;: &quot;1081655792485723&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;下拉复选框&quot;, &quot;renderKey&quot;: &quot;1081655792485723&quot;, &quot;tag&quot;: &quot;el-select&quot;, &quot;type&quot;: 7, &quot;options&quot;: [{ &quot;label&quot;: &quot;选项一&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;选项二&quot;, &quot;value&quot;: 2 }], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;包含任意一个&quot;, &quot;value&quot;: 13 }, { &quot;label&quot;: &quot;同时包含&quot;, &quot;value&quot;: 14 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;select&quot; }}, { &quot;key&quot;: &quot;1091655792486011&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;分割线&quot;, &quot;renderKey&quot;: &quot;1091655792486011&quot;, &quot;tag&quot;: &quot;el-divider&quot;, &quot;type&quot;: 8, &quot;options&quot;: [], &quot;judgeList&quot;: &quot;__vue_devtool_undefined__&quot;, &quot;componentFormat&quot;: &quot;__vue_devtool_undefined__&quot; }}, { &quot;key&quot;: &quot;1101655792486384&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;地址&quot;, &quot;renderKey&quot;: &quot;1101655792486384&quot;, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;type&quot;: 9, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;属于&quot;, &quot;value&quot;: 15 }, { &quot;label&quot;: &quot;不属于&quot;, &quot;value&quot;: 16 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;tree&quot; }}, { &quot;key&quot;: &quot;1111655792487022&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;附件&quot;, &quot;renderKey&quot;: &quot;1111655792487022&quot;, &quot;tag&quot;: &quot;el-upload&quot;, &quot;type&quot;: 11, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;none&quot; }}, { &quot;key&quot;: &quot;1121655792487317&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;图片&quot;, &quot;renderKey&quot;: &quot;1121655792487317&quot;, &quot;tag&quot;: &quot;el-upload&quot;, &quot;type&quot;: 10, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;none&quot; }}, { &quot;key&quot;: &quot;1131655792487550&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;手机&quot;, &quot;renderKey&quot;: &quot;1131655792487550&quot;, &quot;tag&quot;: &quot;el-input&quot;, &quot;type&quot;: 12, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;包含&quot;, &quot;value&quot;: 2 }, { &quot;label&quot;: &quot;已验证&quot;, &quot;value&quot;: 17 }, { &quot;label&quot;: &quot;未验证&quot;, &quot;value&quot;: 18 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;input&quot; }}, { &quot;key&quot;: &quot;1141655792487891&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;成员单选&quot;, &quot;renderKey&quot;: &quot;1141655792487891&quot;, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;type&quot;: 13, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;等于任意一个&quot;, &quot;value&quot;: 11 }, { &quot;label&quot;: &quot;不等于任意一个&quot;, &quot;value&quot;: 12 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;tree&quot; }}, { &quot;key&quot;: &quot;1151655792488133&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;部门单选&quot;, &quot;renderKey&quot;: &quot;1151655792488133&quot;, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;type&quot;: 15, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;不等于&quot;, &quot;value&quot;: 1 }, { &quot;label&quot;: &quot;等于任意一个&quot;, &quot;value&quot;: 11 }, { &quot;label&quot;: &quot;不等于任意一个&quot;, &quot;value&quot;: 12 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }], &quot;componentFormat&quot;: &quot;tree&quot; }}, { &quot;key&quot;: &quot;1161655792488389&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;部门多选&quot;, &quot;renderKey&quot;: &quot;1161655792488389&quot;, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;type&quot;: 16, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }, { &quot;label&quot;: &quot;包含任意一个&quot;, &quot;value&quot;: 13 }, { &quot;label&quot;: &quot;同时包含&quot;, &quot;value&quot;: 14 }], &quot;componentFormat&quot;: &quot;tree&quot; }}, { &quot;key&quot;: &quot;1171655792488689&quot;, &quot;value&quot;: { &quot;label&quot;: &quot;成员多选&quot;, &quot;renderKey&quot;: &quot;1171655792488689&quot;, &quot;tag&quot;: &quot;el-cascader&quot;, &quot;type&quot;: 14, &quot;options&quot;: [], &quot;judgeList&quot;: [{ &quot;label&quot;: &quot;等于&quot;, &quot;value&quot;: 0 }, { &quot;label&quot;: &quot;为空&quot;, &quot;value&quot;: 4 }, { &quot;label&quot;: &quot;不为空&quot;, &quot;value&quot;: 5 }, { &quot;label&quot;: &quot;包含任意一个&quot;, &quot;value&quot;: 13 }, { &quot;label&quot;: &quot;同时包含&quot;, &quot;value&quot;: 14 }], &quot;componentFormat&quot;: &quot;tree&quot; }}] 至此，我们就满足了业务流程中的第 1 点和第 3 点： 根据用户拖拽表单生成的JSON数据(本次采用了FormGenerator去生成JSON数据)，生成对应的所有组件的下拉列表，并在流程图的连接线上添加条件判断。 针对不同组件对应的下拉列表，要求有不同的条件判断，例如：数字类型的需要有范围选择、大小判断、为空不为空，等条件；文本组件有包含不包含，等条件 我们只需提取map中每个组件的renderKey和label作为选项的value和label即可生成所有组件的下拉列表。当然，不要忘了用JSON.parse解析JSON对象后再提取 生成/删除单个下拉列表组件来让我们看看第2个流程： 当用户点击流程图的边时，生成该边上对应的所有组件的下拉列表，在点击某个组件的选项后，生成对应组件的下拉列表组件，在用户取消选择后，对应组件的下拉列表组件随之消失。 我们借鉴Vue的思想，给这个增增删删的组件一个生命周期，那么他大概分为如下几个生命周期： init：点击流程图时，属于init初始化的阶段，判断是否有回显的数据，并组织各类数据去展示。 首先初始化该边的数据，由父组件传递过来，然后判断是否有数据需要回显（initEdgeData） 当边的数据初始化结束后，假如没有数据需要回显，则结束init。否则，添加回显的数据item进已选项中（initSelectedItems） 当选中项存在时，需要初始化选中项对应的组件（initSelectedComponents） update：当已选组件列表发生变化时，更新下拉列表组件 如果是在全部组件列表里添加了新选项，那么就需要将其由renderKey和label的item添加进已选项中 如果是取消了某个选项，删除该选项renderKey对应的数据 如果是更新了已选项的数据，判断是否应该被保存 distory：当全部组件列表的某个已选项取消选择后，删除对应的下拉列表组件。触发update。所以这个阶段可以和update合二为一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190//所有组件下拉列表的vue结构 &lt;!-- 添加流转条件多选列表 --&gt; &lt;el-select v-model=&quot;selectedComponentIds&quot; size=&quot;small&quot; :popper-append-to-body=&quot;false&quot; collapse-tags filterable multiple placeholder=&quot;请选择&quot; @change=&quot;updateSelectedComponents&quot; &gt; &lt;el-option v-for=&quot;item in formComponents&quot; :key=&quot;item.renderKey&quot; :label=&quot;item.label&quot; :value=&quot;item.renderKey&quot; /&gt; &lt;/el-select&gt;// 遍历展示下拉组件的vue结构 &lt;div class=&quot;conditions-items-box&quot;&gt; &lt;!-- key值不同保证更新子组件的值 --&gt; &lt;componentsCard v-for=&quot;item in selectedComponentsAry&quot; :key=&quot;JSON.stringify(item.condition)&quot; :custom-component=&quot;item&quot; :cur-judge=&quot;curJudge&quot; @changeCurJudge=&quot;showJudge&quot; @saveComponent=&quot;saveComponent&quot; /&gt; &lt;/div&gt;&lt;script&gt;import componentsCard from '@/components/workflow/PropertySetting/componentsCard';import { getComponentMap } from '@/utils/adpterForForm';components: { componentsCard },data() { return { conditionOptions: [{ value: 0, label: '使用自定义流转条件' }, { value: 1, label: '使用Else条件' }], choseType: false, isAll: false, selectedCondition: 0, formComponents: [], // 用于遍历展示所有组件的选项列表 componentsMap: null, // 存放所有组件的基础信息 selectedComponentIds: [], // 存放所有已选组件的renderKey（唯一id） selectedComponentsAry: null, // 遍历展示每个组件下拉列表组件 curJudge: -1, form: null, // 拷贝当前边的自定义数据 saveMap: new Map() // 仅保存conditions，这是后端要求的，即renderKey、Judge、content }; },// 通过watch监听边的变化并获取数据watch: { // 边更新后初始化数据 nodeData: function(val) { if (val.type === 'customEdge') { this.initEdgeData(val); } } },// Vue组件初始化时created() { // 构建组件map，key为renderKey，value为组件所有的基本信息 // 把表单数据存在了localStorage里面防止刷新页面后表单数据丢失 this.componentsMap = getComponentMap(JSON.parse(window.localStorage.drawingItems)); // 获取表单数据并展示选择列表。这里就是v-for展示下拉选项用的 this.formComponents = [...this.componentsMap.values()]; // 此处可以优化，只用到了label和renderKey，存在一个数据冗余的问题 可以遍历解构label和value。 }, methods:{ // 初始化边的条件数据 initEdgeData(data) { // 提取边的自定义属性properties，并拷贝一份到当前实例（不需要深拷贝） // 便于在保存数据时直接拿来save替换掉老数据 // 保存的数据都存在properties.conditions里面 const { properties } = data; if (properties) { this.$data.form = Object.assign({}, this.$data.form, properties); } // 更新当前选中项 this.initSelectedItems(data); // 更新当前选中项对应的自定义组件 this.initSelectedComponents(this.$data.form.conditions); }, // 初始化选中项 initSelectedItems(data) { // 初始化选中项数组。 this.selectedComponentIds = []; // 将边上之前添加过的数据回显出来 data.properties.conditions.forEach(item =&gt; { this.selectedComponentIds.push(item.renderKey); }); }, // 初始化选中项对应的组件，此时除了初始化组件的基本信息外，还会添加已选组件的用户输入信息，即conditionList initSelectedComponents(conditionList) { const ary = []; // 遍历当前选中项，更新条件map和卡片数组 for (const item of conditionList) { // 此处需要深拷贝，componentsMap获取的是一份地址，直接操作会污染componentsMap const componentObj = Object.create(this.componentsMap.get(item.renderKey)); componentObj.condition = item; ary.push(componentObj); // 初始化要保存的map，map保存的仅有conditions，这是后端要求的 /* conditions形如 *{ * renderKey:唯一id * Judge:条件 * content:内容 *} */ this.saveMap.set(item.renderKey, item); } // 更新当前选中项对应的组件卡片数组 this.selectedComponentsAry = ary; }, // 更新当前选中项对应的组件 // 此方法在触发下拉列表事@change件时传入已选项的renderKey的list // 使用renderKey，控制条件组件的展示 updateSelectedComponents(idList) { const ary = []; // 用于遍历展示用的已选项数组 const newSaveMap = new Map(); // 用于替换saveMap的新map，数据格式和saveMap一样，是update后的saveMap let saveMapItem = null; // 判断是否已存在该数据，是延用数据还是初始化保存项 // 遍历当前选中项，更新newSaveMap和卡片数组 // item为renderKey（唯一id） for (const item of idList) { // 此处需要浅拷贝，直接操作会污染componentsMap（组件的基本信息） const componentObj = Object.create(this.componentsMap.get(item)); // 目标组件的基本信息 saveMapItem = this.saveMap.get(item); // 向组件添加要入库的condition信息，即用户输入的信息 // 同时判断该数据是否已存在，是延用数据还是初始化数据 // 这么做的原因是因为无法获取到最新添加/删除的id，只能获得所有的id，然后遍历替换数据，所以已存在的老数据需要保留 componentObj.condition = saveMapItem ? saveMapItem : { Judge: -1, // 条件默认为 请选择 content: null, // 选择的内容默认为 null renderKey: item // 唯一id }; ary.push(componentObj); // 用于遍历展示用的已选项数组 newSaveMap.set(item, this.saveMap.get(item)); // 向准备替换的map内添加数据 } // 更新要存入节点的map this.saveMap = newSaveMap; this.form.conditions = this.filterSaveData(); // 更新当前选中项对应的组件卡片数组 this.selectedComponentsAry = ary; this.saveData(); }, // 新添加的下拉列表组件值被修改后触发 saveComponent(conditions) { const { Judge: judge, renderKey } = conditions; if (judge !== -1) { this.saveMap.set(renderKey, conditions); } this.form.conditions = this.filterSaveData(); this.saveData(); } // 过滤可保存数据 filterSaveData() { this.form.conditions = [...this.saveMap.values()].filter(item =&gt; { if (item &amp;&amp; item.judge !== -1) { // 选择了条件 if (item.judge === 4 || item.judge === 5) { // 条件是 为空 和 不为空 不需要content有值 return item; } else if (item.content !== '' &amp;&amp; item.content !== null &amp;&amp; item.content !== undefined) { // 其他条件content必须有值才通过过滤 return item; } } }); }, // 保存数据到当前选中元素 saveData() { const { id } = this.$props.nodeData; // logicFlow的保存节点信息的Api this.$props.lf.setProperties(id, this.$data.form); }, } &lt;/script&gt; 至此，我们已经完成了流程2的所有逻辑。 当用户点击流程图的边时，生成该边上对应的所有组件的下拉列表，在点击某个组件的选项后，生成对应组件的下拉列表组件，在用户取消选择后，对应组件的下拉列表组件随之消失。 因为流程3的逻辑在我们编写工具类时就已经搞定了，所以进入流程4 当用户选择后，自动保存到当前边对应的JSON数据，若用户的选择无效，则不保存 子组件的编写+数据保存子组件采用工厂模式写了一个工厂组件，这里起得名字叫componentsCard，通过组件内部的componentFormat属性决定该组件该如何展示。该属性在解构的时候通过tag属性添加。 当用户在全部组件的下拉列表选择后，该组件的renderKey就会被添加进已选项中，假如用户并没有进行任何操作，则该条数据会被filterSaveData过滤掉，被认为是无效数据。只有满足filterSaveData过滤条件的数据才会被存入当前边的JSON数据中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208// 只展示了部分关键代码 .... &lt;div class=&quot;container-title&quot;&gt; &lt;div class=&quot;title-name&quot;&gt; {{ customComponent.label }} &lt;/div&gt; &lt;div class=&quot;title-conditions&quot; @click=&quot;showJudgeList(customComponent)&quot;&gt; {{ selectedItem.label }} &lt;i class=&quot;icon-wf-caretdown iconfont&quot; /&gt; &lt;div v-if=&quot;+curJudge === +customComponent.renderKey&quot; class=&quot;list-box&quot;&gt; &lt;div v-for=&quot;(item,index) in customComponent.judgeList &quot; :key=&quot;index&quot; class=&quot;list-item&quot; @click.capture.stop=&quot;selectItem(item)&quot; &gt; {{ item.label }} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ....&lt;!-- 为空或不为空作为条件时，该选项不显示 --&gt; &lt;div v-show=&quot;showContent&quot;&gt; &lt;div v-if=&quot;customComponent.componentFormat === 'input'&quot; class=&quot;content&quot; &gt; &lt;el-input v-show=&quot;selectedItem.value !== 4 &amp;&amp; selectedItem.value !== 5&quot; v-model=&quot;content&quot; @change=&quot;saveData&quot; /&gt; &lt;/div&gt; &lt;div v-if=&quot;customComponent.componentFormat === 'select'&quot; class=&quot;content&quot; &gt; &lt;!-- 单选列表 --&gt; &lt;el-select v-show=&quot;!isMultipleSelect&quot; v-model=&quot;content&quot; @change=&quot;saveData&quot; &gt; &lt;el-option v-for=&quot;item in customComponent.options&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot; /&gt; &lt;/el-select&gt; &lt;!-- 多选列表 --&gt; &lt;el-select v-show=&quot;isMultipleSelect&quot; v-model=&quot;contentAry&quot; multiple placeholder=&quot;请选择&quot; @change=&quot;saveDataAry&quot; &gt; &lt;el-option v-for=&quot;item in customComponent.options&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot; /&gt; &lt;/el-select&gt; &lt;/div&gt; &lt;div v-if=&quot;customComponent.componentFormat === 'date'&quot; class=&quot;content&quot; &gt; &lt;el-date-picker v-show=&quot;!isRange&quot; v-model=&quot;content&quot; type=&quot;date&quot; placeholder=&quot;选择日期&quot; value-format=&quot;timestamp&quot; @change=&quot;saveData&quot; /&gt; &lt;el-date-picker v-show=&quot;isRange&quot; v-model=&quot;contentAry&quot; type=&quot;daterange&quot; range-separator=&quot;~&quot; value-format=&quot;timestamp&quot; @change=&quot;saveDataAry&quot; /&gt; &lt;/div&gt; &lt;div v-if=&quot;customComponent.componentFormat === 'tree'&quot; class=&quot;content&quot; &gt; &lt;el-cascader v-model=&quot;content&quot; :options=&quot;customComponent.options&quot; @change=&quot;saveData&quot; /&gt; &lt;/div&gt; &lt;div v-if=&quot;customComponent.componentFormat === 'none'&quot; class=&quot;content&quot; /&gt; &lt;/div&gt; &lt;script&gt;export default { props: { curJudge: { type: Number, default: -1 }, customComponent: { type: Object, default: () =&gt; {} } }, data() { return { selectedItem: { label: '请选择', value: -1 }, // 条件字段选择的item content: '', // 内容 contentAry: [], // 内容也可能是数组（范围选择时） multipleSelectVal: [2, 3, 11, 12, 13, 14], // 这些值表示可以进行多选 rangeVal: [10] // 这些值表示是范围选择, }; }, computed: { // 要保存的数据 sendData: function() { return { content: this.content, renderKey: this.customComponent.renderKey, Judge: this.selectedItem.value }; }, sendDataAry: function() { return { content: this.contentAry, renderKey: this.customComponent.renderKey, Judge: this.selectedItem.value }; }, // 是否展示输入框 showContent: function() { return this.selectedItem.value !== 4 &amp;&amp; this.selectedItem.value !== 5; }, // 是否多选 isMultipleSelect: function() { return this.findVal(this.multipleSelectVal, this.selectedItem.value); }, // 是否范围选择 isRange: function() { return this.findVal(this.rangeVal, this.selectedItem.value); } }, mounted() { // 判断显示的内容是 数组 还是 字符串/数字 Array.isArray(this.customComponent.condition.content) ? this.contentAry = this.customComponent.condition.content : this.content = this.customComponent.condition.content; // 已选值传入时需要回显，找到对应的选项 const initSelectJudge = this.customComponent.judgeList.find(options =&gt; { return options.value === this.customComponent.condition.Judge; }); // 初始化当前组件条件选项的值 this.selectedItem = initSelectJudge || this.selectedItem; }, methods: { selectItem(item) { this.selectedItem = item; // 选择完关闭条件列表 this.$emit('changeCurJudge', -1); this.content = null; this.contentAry = null; // 这里将数据是否保存的判断全部交由父组件去处理了，这里本来是只有选择 为空/不为空 才会发送 // 原因1 // 数据保存的条件是blur，所以当更改数据后就需要确认数据是否能够被保存（这里和流程图的设计有关） // 原因2 // 但即使父组件接收到了数据，也需要额外的判断流程，不如就将所有的判断逻辑都交由了父组件处理 // 这样子组件只管选择就行了，后期即使需要更改也只需要更改父组件的判断逻辑 // 原因3 // 这样在用户切换条件时，能够重置输入框 this.$emit('saveComponent', this.sendData); }, showJudgeList(item) { this.$emit('changeCurJudge', item.renderKey); }, // 保存数据，通过计算属性包装的data直接发送 saveData(val) { this.content = val; this.$emit('saveComponent', this.sendData); }, // 保存数据，通过计算属性包装的data直接发送 saveDataAry(val) { this.contentAry = val; this.$emit('saveComponent', this.sendDataAry); }, // 工具方法，找数用的 findVal(ary, val) { return ary.find(item =&gt; { return item === val; }); } }};&lt;/script&gt; 这样子组件就可以在数据更改后向父组件通知，并将所有的判断逻辑交由父组件处理，将子组件的功能尽量简化。避免后期在维护时还需要关注子组件的判断逻辑。 而且通过工厂组件，当需要新加组件时也只需要去维护一个componentCard组件就行了，逻辑完全可以复用。 到这，业务流程4就能跑通了。 当用户选择后，自动保存到当前边对应的JSON数据，若用户的选择无效，则不保存。 至于业务流程5 要求能够回显用户选择的数据，即点击不同边时，回显该边上JSON对应的所有下拉列表组件 因为在父组件使用了watch，当节点发生变化时，会重新执行init阶段的各种方法，从而做到数据回显。 总结做这种组件还是需要理清楚逻辑，多多关注细节问题。同时尽量让逻辑简单起来。当然肯定存在不少更优的写法，不过目前还考虑不到，欢迎各位大佬评论指正。","link":"/2022/09/02/%E6%A0%B9%E6%8D%AE%E7%BB%84%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E4%B8%8B%E6%8B%89%E6%A1%86%E5%8F%8A%E9%80%89%E9%A1%B9/"},{"title":"跨域常见的解决方法","text":"跨域概念浏览器中有一个安全策略叫同源策略，意思是协议、主机、端口必须相同，如果其一不同，则称之为跨域，对于跨域的请求，出于安全考虑，浏览器会对其访问进行一些限制 Ajax对于传统ajax，浏览器默认不允许其发送跨域请求，但是有三种方案可以解决 代理 代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域比较常见的是通过webpack集成的 devServer 实现代理去解决跨域问题 1234567891011// vue 的开发服务器代理配置// vue.config.jsmodule.exports = { devServer: { // 配置开发服务器 proxy: { // 配置代理 &quot;/api&quot;: { // 若请求路径以 /api 开头 target: &quot;http://dev.taobao.com&quot;, // 将其转发到 http://dev.taobao.com }, }, },}; JSONP 通过前后端配合，利用 script 标签不受同源策略限制去令服务端响应一段JS代码，将需要返回的数据作为参数传入该代码中，客户端再负责调用，类似ajax的回调函数。 但JSONP有一个明显的问题就是只能发送Get请求 CORS CORS是基于http1.1的一种跨域解决方案。全称叫跨域资源共享总体思路是：如果浏览器要跨域访问服务器的资源，需要获得服务器的允许针对不同的请求，CORS 规定了三种不同的交互模式，分别是：简单请求、需要预检的请求、附带身份凭证的请求。 当请求方法属于get、post、head；请求头仅包含安全的字段；请求头如果包含Content-Type，仅限 text/plain、multipart/form-data、application/x-www-form-urlencoded；同时满足上面三个条件后则判断为简单请求。 常见的安全字段如下： Accept Accept-Language Content-Language Content-Type DPR Downlink Save-Data Viewport-Width Width 当浏览器判断某个请求为简单请求后，会在请求头中自动添加 Origin 字段，用以告诉服务器，是哪个源地址在跨域请求，服务器在收到请求后，需要添加 Access-Control-Allow-Origin 用以表示开放的权限（* 表示允许所有，也可以写具体的地址表示只允许该源下的请求访问） 对于需要预检的请求（不符合上述条件），浏览器会先发送预检请求，如果服务器允许访问，则浏览器发送真实请求，最后服务器完成真实请求的响应 预检请求有以下特征： 请求方法为OPTIONS 没有请求体 请求头中包含 Origin：请求的源，和简单请求的含义一致 Access-Control-Request-Method：后续的真实请求将使用的请求方法 Access-Control-Request-Headers：后续的真实请求会改动的请求头 对于预检请求的响应，不需要请求体，只需要在响应头中添加 Access-Control-Allow-Origin：和简单请求一样，表示允许的源 Access-Control-Allow-Methods：表示允许的后续真实的请求方法 Access-Control-Allow-Headers：表示允许改动的请求头 Access-Control-Max-Age：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了 默认情况下，ajax 的跨域请求并不会附带 cookie，这样一来，某些需要权限的操作就无法进行，不过可以通过简单的配置就可以实现附带 cookie，xhr通过 withCredentials = true 配置，fetch 通过 init 参数对象中的 credentials配置。这样一来该请求就是一个附带身份凭证的请求，会在请求头中添加 cookie 字段。服务器需要在响应头中添加 Access-Control-Allow-Credentials: true即可 **对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为***。 参考文章：Http跨域资源共享 MDN前端面试必会网络之跨域问题解决","link":"/2022/09/02/%E8%B7%A8%E5%9F%9F/"}],"tags":[{"name":"Echarts","slug":"Echarts","link":"/tags/Echarts/"},{"name":"Api","slug":"Api","link":"/tags/Api/"},{"name":"懒加载","slug":"懒加载","link":"/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"name":"垃圾回收","slug":"垃圾回收","link":"/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Hbuilder","slug":"Hbuilder","link":"/tags/Hbuilder/"},{"name":"国际化","slug":"国际化","link":"/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"},{"name":"i18n","slug":"i18n","link":"/tags/i18n/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"事件循环","slug":"事件循环","link":"/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"微任务","slug":"微任务","link":"/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","link":"/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"},{"name":"状态模式","slug":"状态模式","link":"/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"name":"业务场景","slug":"业务场景","link":"/tags/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/"},{"name":"单例模式","slug":"单例模式","link":"/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"跨域","slug":"跨域","link":"/tags/%E8%B7%A8%E5%9F%9F/"}],"categories":[{"name":"问题解决方案","slug":"问题解决方案","link":"/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"事件循环","slug":"前端/事件循环","link":"/categories/%E5%89%8D%E7%AB%AF/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"业务场景","slug":"业务场景","link":"/categories/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/"},{"name":"个性化","slug":"hexo/个性化","link":"/categories/hexo/%E4%B8%AA%E6%80%A7%E5%8C%96/"}],"pages":[]}